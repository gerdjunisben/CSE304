Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DECLARE
    DO
    LBRACKET
    NUMBER
    RBRACKET
    STRING
    SYMBOLS
    TERMINALS

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> class_decl
Rule 3     program -> class_decl program
Rule 4     class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE
Rule 5     class_decl -> CLASS ID LBRACE class_body_decl RBRACE
Rule 6     class_body_decl -> class_body_sub_decls
Rule 7     class_body_sub_decls -> field_decl SEMICOLON class_body_sub_decls
Rule 8     class_body_sub_decls -> method_decl class_body_sub_decls
Rule 9     class_body_sub_decls -> constructor_decl class_body_sub_decls
Rule 10    class_body_sub_decls -> field_decl SEMICOLON
Rule 11    class_body_sub_decls -> constructor_decl
Rule 12    class_body_sub_decls -> method_decl
Rule 13    class_body_sub_decls -> empty
Rule 14    field_decl -> modifier var_decl
Rule 15    modifier -> visibility applicability
Rule 16    modifier -> visibility
Rule 17    modifier -> applicability
Rule 18    modifier -> empty
Rule 19    visibility -> PUBLIC
Rule 20    visibility -> PRIVATE
Rule 21    applicability -> STATIC
Rule 22    var_decl -> type variables
Rule 23    type -> INT
Rule 24    type -> FLOAT
Rule 25    type -> BOOLEAN
Rule 26    type -> VOID
Rule 27    type -> ID
Rule 28    variables -> variable
Rule 29    variables -> variables COMMA variable
Rule 30    variables -> empty
Rule 31    variable -> ID
Rule 32    method_decl -> modifier type ID LPAREN RPAREN block
Rule 33    method_decl -> modifier VOID ID LPAREN RPAREN block
Rule 34    method_decl -> modifier type ID LPAREN formals RPAREN block
Rule 35    method_decl -> modifier VOID ID LPAREN formals RPAREN block
Rule 36    constructor_decl -> modifier ID LPAREN RPAREN block
Rule 37    constructor_decl -> modifier ID LPAREN formals RPAREN block
Rule 38    formals -> formals COMMA formal_param
Rule 39    formals -> formal_param
Rule 40    formals -> empty
Rule 41    formal_param -> type variable
Rule 42    block -> LBRACE block_end RBRACE
Rule 43    block_end -> stmt
Rule 44    block_end -> stmt block_end
Rule 45    block_end -> empty
Rule 46    stmt -> IF LPAREN expr RPAREN stmt
Rule 47    stmt -> IF LPAREN expr RPAREN stmt ELSE stmt
Rule 48    stmt -> WHILE LPAREN expr RPAREN stmt
Rule 49    stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
Rule 50    stmt -> RETURN SEMICOLON
Rule 51    stmt -> RETURN expr SEMICOLON
Rule 52    stmt -> stmt_expr SEMICOLON
Rule 53    stmt -> BREAK SEMICOLON
Rule 54    stmt -> CONTINUE SEMICOLON
Rule 55    stmt -> block
Rule 56    stmt -> var_decl SEMICOLON
Rule 57    stmt -> SEMICOLON
Rule 58    literal -> INTCONST
Rule 59    literal -> FLOATCONST
Rule 60    literal -> STRINGCONST
Rule 61    literal -> NULL
Rule 62    literal -> TRUE
Rule 63    literal -> FALSE
Rule 64    primary -> literal
Rule 65    primary -> THIS
Rule 66    primary -> SUPER
Rule 67    primary -> LPAREN expr RPAREN
Rule 68    primary -> NEW ID LPAREN arguments RPAREN
Rule 69    primary -> NEW ID LPAREN RPAREN
Rule 70    primary -> lhs
Rule 71    primary -> method_invocation
Rule 72    arguments -> expr
Rule 73    arguments -> arguments COMMA expr
Rule 74    arguments -> empty
Rule 75    lhs -> field_access
Rule 76    method_invocation -> field_access LPAREN RPAREN
Rule 77    method_invocation -> field_access LPAREN arguments RPAREN
Rule 78    field_access -> primary PERIOD ID
Rule 79    field_access -> ID
Rule 80    expr -> primary
Rule 81    expr -> assign
Rule 82    expr -> expr arith_op expr
Rule 83    expr -> expr bool_op expr
Rule 84    expr -> unary_op expr
Rule 85    assign -> lhs EQUALS expr
Rule 86    assign -> lhs PLUSPLUS
Rule 87    assign -> PLUSPLUS lhs
Rule 88    assign -> lhs MINUSMINUS
Rule 89    assign -> MINUSMINUS lhs
Rule 90    arith_op -> PLUS
Rule 91    arith_op -> MINUS
Rule 92    arith_op -> TIMES
Rule 93    arith_op -> DIVIDE
Rule 94    bool_op -> AND
Rule 95    bool_op -> OR
Rule 96    bool_op -> EQUALSCOMPARE
Rule 97    bool_op -> NOTEQUALS
Rule 98    bool_op -> LESSTHAN
Rule 99    bool_op -> GREATERTHAN
Rule 100   bool_op -> LESSTHANOREQ
Rule 101   bool_op -> GREATERTHANOREQ
Rule 102   unary_op -> PLUS
Rule 103   unary_op -> MINUS
Rule 104   unary_op -> NOT
Rule 105   stmt_expr -> assign
Rule 106   stmt_expr -> method_invocation

Terminals, with rules where they appear

AND                  : 94
BOOLEAN              : 25
BREAK                : 53
CLASS                : 4 5
COMMA                : 29 38 73
CONTINUE             : 54
DECLARE              : 
DIVIDE               : 93
DO                   : 
ELSE                 : 47
EQUALS               : 85
EQUALSCOMPARE        : 96
EXTENDS              : 4
FALSE                : 63
FLOAT                : 24
FLOATCONST           : 59
FOR                  : 49
GREATERTHAN          : 99
GREATERTHANOREQ      : 101
ID                   : 4 4 5 27 31 32 33 34 35 36 37 68 69 78 79
IF                   : 46 47
INT                  : 23
INTCONST             : 58
LBRACE               : 4 5 42
LBRACKET             : 
LESSTHAN             : 98
LESSTHANOREQ         : 100
LPAREN               : 32 33 34 35 36 37 46 47 48 49 67 68 69 76 77
MINUS                : 91 103
MINUSMINUS           : 88 89
NEW                  : 68 69
NOT                  : 104
NOTEQUALS            : 97
NULL                 : 61
NUMBER               : 
OR                   : 95
PERIOD               : 78
PLUS                 : 90 102
PLUSPLUS             : 86 87
PRIVATE              : 20
PUBLIC               : 19
RBRACE               : 4 5 42
RBRACKET             : 
RETURN               : 50 51
RPAREN               : 32 33 34 35 36 37 46 47 48 49 67 68 69 76 77
SEMICOLON            : 7 10 49 49 50 51 52 53 54 56 57
STATIC               : 21
STRING               : 
STRINGCONST          : 60
SUPER                : 66
SYMBOLS              : 
TERMINALS            : 
THIS                 : 65
TIMES                : 92
TRUE                 : 62
VOID                 : 26 33 35
WHILE                : 48
error                : 

Nonterminals, with rules where they appear

applicability        : 15 17
arguments            : 68 73 77
arith_op             : 82
assign               : 81 105
block                : 32 33 34 35 36 37 55
block_end            : 42 44
bool_op              : 83
class_body_decl      : 4 5
class_body_sub_decls : 6 7 8 9
class_decl           : 2 3
constructor_decl     : 9 11
empty                : 13 18 30 40 45 74
expr                 : 46 47 48 49 51 67 72 73 82 82 83 83 84 85
field_access         : 75 76 77
field_decl           : 7 10
formal_param         : 38 39
formals              : 34 35 37 38
lhs                  : 70 85 86 87 88 89
literal              : 64
method_decl          : 8 12
method_invocation    : 71 106
modifier             : 14 32 33 34 35 36 37
primary              : 78 80
program              : 3 0
stmt                 : 43 44 46 47 47 48 49
stmt_expr            : 49 49 52
type                 : 22 32 34 41
unary_op             : 84
var_decl             : 14 56
variable             : 28 29 41
variables            : 22 29
visibility           : 15 16

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . class_decl
    (3) program -> . class_decl program
    (4) class_decl -> . CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE
    (5) class_decl -> . CLASS ID LBRACE class_body_decl RBRACE

    CLASS           shift and go to state 3

    program                        shift and go to state 1
    class_decl                     shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (2) program -> class_decl .
    (3) program -> class_decl . program
    (2) program -> . class_decl
    (3) program -> . class_decl program
    (4) class_decl -> . CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE
    (5) class_decl -> . CLASS ID LBRACE class_body_decl RBRACE

    $end            reduce using rule 2 (program -> class_decl .)
    CLASS           shift and go to state 3

    class_decl                     shift and go to state 2
    program                        shift and go to state 4

state 3

    (4) class_decl -> CLASS . ID EXTENDS ID LBRACE class_body_decl RBRACE
    (5) class_decl -> CLASS . ID LBRACE class_body_decl RBRACE

    ID              shift and go to state 5


state 4

    (3) program -> class_decl program .

    $end            reduce using rule 3 (program -> class_decl program .)


state 5

    (4) class_decl -> CLASS ID . EXTENDS ID LBRACE class_body_decl RBRACE
    (5) class_decl -> CLASS ID . LBRACE class_body_decl RBRACE

    EXTENDS         shift and go to state 6
    LBRACE          shift and go to state 7


state 6

    (4) class_decl -> CLASS ID EXTENDS . ID LBRACE class_body_decl RBRACE

    ID              shift and go to state 8


state 7

    (5) class_decl -> CLASS ID LBRACE . class_body_decl RBRACE
    (6) class_body_decl -> . class_body_sub_decls
    (7) class_body_sub_decls -> . field_decl SEMICOLON class_body_sub_decls
    (8) class_body_sub_decls -> . method_decl class_body_sub_decls
    (9) class_body_sub_decls -> . constructor_decl class_body_sub_decls
    (10) class_body_sub_decls -> . field_decl SEMICOLON
    (11) class_body_sub_decls -> . constructor_decl
    (12) class_body_sub_decls -> . method_decl
    (13) class_body_sub_decls -> . empty
    (14) field_decl -> . modifier var_decl
    (32) method_decl -> . modifier type ID LPAREN RPAREN block
    (33) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (34) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (35) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (36) constructor_decl -> . modifier ID LPAREN RPAREN block
    (37) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (1) empty -> .
    (15) modifier -> . visibility applicability
    (16) modifier -> . visibility
    (17) modifier -> . applicability
    (18) modifier -> . empty
    (19) visibility -> . PUBLIC
    (20) visibility -> . PRIVATE
    (21) applicability -> . STATIC

    RBRACE          reduce using rule 1 (empty -> .)
    VOID            reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    BOOLEAN         reduce using rule 1 (empty -> .)
    PUBLIC          shift and go to state 18
    PRIVATE         shift and go to state 19
    STATIC          shift and go to state 20

    class_body_decl                shift and go to state 9
    class_body_sub_decls           shift and go to state 10
    field_decl                     shift and go to state 11
    method_decl                    shift and go to state 12
    constructor_decl               shift and go to state 13
    empty                          shift and go to state 14
    modifier                       shift and go to state 15
    visibility                     shift and go to state 16
    applicability                  shift and go to state 17

state 8

    (4) class_decl -> CLASS ID EXTENDS ID . LBRACE class_body_decl RBRACE

    LBRACE          shift and go to state 21


state 9

    (5) class_decl -> CLASS ID LBRACE class_body_decl . RBRACE

    RBRACE          shift and go to state 22


state 10

    (6) class_body_decl -> class_body_sub_decls .

    RBRACE          reduce using rule 6 (class_body_decl -> class_body_sub_decls .)


state 11

    (7) class_body_sub_decls -> field_decl . SEMICOLON class_body_sub_decls
    (10) class_body_sub_decls -> field_decl . SEMICOLON

    SEMICOLON       shift and go to state 23


state 12

    (8) class_body_sub_decls -> method_decl . class_body_sub_decls
    (12) class_body_sub_decls -> method_decl .
    (7) class_body_sub_decls -> . field_decl SEMICOLON class_body_sub_decls
    (8) class_body_sub_decls -> . method_decl class_body_sub_decls
    (9) class_body_sub_decls -> . constructor_decl class_body_sub_decls
    (10) class_body_sub_decls -> . field_decl SEMICOLON
    (11) class_body_sub_decls -> . constructor_decl
    (12) class_body_sub_decls -> . method_decl
    (13) class_body_sub_decls -> . empty
    (14) field_decl -> . modifier var_decl
    (32) method_decl -> . modifier type ID LPAREN RPAREN block
    (33) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (34) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (35) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (36) constructor_decl -> . modifier ID LPAREN RPAREN block
    (37) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (1) empty -> .
    (15) modifier -> . visibility applicability
    (16) modifier -> . visibility
    (17) modifier -> . applicability
    (18) modifier -> . empty
    (19) visibility -> . PUBLIC
    (20) visibility -> . PRIVATE
    (21) applicability -> . STATIC

  ! reduce/reduce conflict for RBRACE resolved using rule 1 (empty -> .)
    RBRACE          reduce using rule 1 (empty -> .)
    VOID            reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    BOOLEAN         reduce using rule 1 (empty -> .)
    PUBLIC          shift and go to state 18
    PRIVATE         shift and go to state 19
    STATIC          shift and go to state 20

  ! RBRACE          [ reduce using rule 12 (class_body_sub_decls -> method_decl .) ]

    method_decl                    shift and go to state 12
    class_body_sub_decls           shift and go to state 24
    field_decl                     shift and go to state 11
    constructor_decl               shift and go to state 13
    empty                          shift and go to state 14
    modifier                       shift and go to state 15
    visibility                     shift and go to state 16
    applicability                  shift and go to state 17

state 13

    (9) class_body_sub_decls -> constructor_decl . class_body_sub_decls
    (11) class_body_sub_decls -> constructor_decl .
    (7) class_body_sub_decls -> . field_decl SEMICOLON class_body_sub_decls
    (8) class_body_sub_decls -> . method_decl class_body_sub_decls
    (9) class_body_sub_decls -> . constructor_decl class_body_sub_decls
    (10) class_body_sub_decls -> . field_decl SEMICOLON
    (11) class_body_sub_decls -> . constructor_decl
    (12) class_body_sub_decls -> . method_decl
    (13) class_body_sub_decls -> . empty
    (14) field_decl -> . modifier var_decl
    (32) method_decl -> . modifier type ID LPAREN RPAREN block
    (33) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (34) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (35) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (36) constructor_decl -> . modifier ID LPAREN RPAREN block
    (37) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (1) empty -> .
    (15) modifier -> . visibility applicability
    (16) modifier -> . visibility
    (17) modifier -> . applicability
    (18) modifier -> . empty
    (19) visibility -> . PUBLIC
    (20) visibility -> . PRIVATE
    (21) applicability -> . STATIC

  ! reduce/reduce conflict for RBRACE resolved using rule 1 (empty -> .)
    RBRACE          reduce using rule 1 (empty -> .)
    VOID            reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    BOOLEAN         reduce using rule 1 (empty -> .)
    PUBLIC          shift and go to state 18
    PRIVATE         shift and go to state 19
    STATIC          shift and go to state 20

  ! RBRACE          [ reduce using rule 11 (class_body_sub_decls -> constructor_decl .) ]

    constructor_decl               shift and go to state 13
    class_body_sub_decls           shift and go to state 25
    field_decl                     shift and go to state 11
    method_decl                    shift and go to state 12
    empty                          shift and go to state 14
    modifier                       shift and go to state 15
    visibility                     shift and go to state 16
    applicability                  shift and go to state 17

state 14

    (13) class_body_sub_decls -> empty .
    (18) modifier -> empty .

    RBRACE          reduce using rule 13 (class_body_sub_decls -> empty .)
    VOID            reduce using rule 18 (modifier -> empty .)
    ID              reduce using rule 18 (modifier -> empty .)
    INT             reduce using rule 18 (modifier -> empty .)
    FLOAT           reduce using rule 18 (modifier -> empty .)
    BOOLEAN         reduce using rule 18 (modifier -> empty .)


state 15

    (14) field_decl -> modifier . var_decl
    (32) method_decl -> modifier . type ID LPAREN RPAREN block
    (33) method_decl -> modifier . VOID ID LPAREN RPAREN block
    (34) method_decl -> modifier . type ID LPAREN formals RPAREN block
    (35) method_decl -> modifier . VOID ID LPAREN formals RPAREN block
    (36) constructor_decl -> modifier . ID LPAREN RPAREN block
    (37) constructor_decl -> modifier . ID LPAREN formals RPAREN block
    (22) var_decl -> . type variables
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . BOOLEAN
    (26) type -> . VOID
    (27) type -> . ID

    VOID            shift and go to state 29
    ID              shift and go to state 28
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32

    var_decl                       shift and go to state 26
    type                           shift and go to state 27

state 16

    (15) modifier -> visibility . applicability
    (16) modifier -> visibility .
    (21) applicability -> . STATIC

    VOID            reduce using rule 16 (modifier -> visibility .)
    ID              reduce using rule 16 (modifier -> visibility .)
    INT             reduce using rule 16 (modifier -> visibility .)
    FLOAT           reduce using rule 16 (modifier -> visibility .)
    BOOLEAN         reduce using rule 16 (modifier -> visibility .)
    STATIC          shift and go to state 20

    applicability                  shift and go to state 33

state 17

    (17) modifier -> applicability .

    VOID            reduce using rule 17 (modifier -> applicability .)
    ID              reduce using rule 17 (modifier -> applicability .)
    INT             reduce using rule 17 (modifier -> applicability .)
    FLOAT           reduce using rule 17 (modifier -> applicability .)
    BOOLEAN         reduce using rule 17 (modifier -> applicability .)


state 18

    (19) visibility -> PUBLIC .

    STATIC          reduce using rule 19 (visibility -> PUBLIC .)
    VOID            reduce using rule 19 (visibility -> PUBLIC .)
    ID              reduce using rule 19 (visibility -> PUBLIC .)
    INT             reduce using rule 19 (visibility -> PUBLIC .)
    FLOAT           reduce using rule 19 (visibility -> PUBLIC .)
    BOOLEAN         reduce using rule 19 (visibility -> PUBLIC .)


state 19

    (20) visibility -> PRIVATE .

    STATIC          reduce using rule 20 (visibility -> PRIVATE .)
    VOID            reduce using rule 20 (visibility -> PRIVATE .)
    ID              reduce using rule 20 (visibility -> PRIVATE .)
    INT             reduce using rule 20 (visibility -> PRIVATE .)
    FLOAT           reduce using rule 20 (visibility -> PRIVATE .)
    BOOLEAN         reduce using rule 20 (visibility -> PRIVATE .)


state 20

    (21) applicability -> STATIC .

    VOID            reduce using rule 21 (applicability -> STATIC .)
    ID              reduce using rule 21 (applicability -> STATIC .)
    INT             reduce using rule 21 (applicability -> STATIC .)
    FLOAT           reduce using rule 21 (applicability -> STATIC .)
    BOOLEAN         reduce using rule 21 (applicability -> STATIC .)


state 21

    (4) class_decl -> CLASS ID EXTENDS ID LBRACE . class_body_decl RBRACE
    (6) class_body_decl -> . class_body_sub_decls
    (7) class_body_sub_decls -> . field_decl SEMICOLON class_body_sub_decls
    (8) class_body_sub_decls -> . method_decl class_body_sub_decls
    (9) class_body_sub_decls -> . constructor_decl class_body_sub_decls
    (10) class_body_sub_decls -> . field_decl SEMICOLON
    (11) class_body_sub_decls -> . constructor_decl
    (12) class_body_sub_decls -> . method_decl
    (13) class_body_sub_decls -> . empty
    (14) field_decl -> . modifier var_decl
    (32) method_decl -> . modifier type ID LPAREN RPAREN block
    (33) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (34) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (35) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (36) constructor_decl -> . modifier ID LPAREN RPAREN block
    (37) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (1) empty -> .
    (15) modifier -> . visibility applicability
    (16) modifier -> . visibility
    (17) modifier -> . applicability
    (18) modifier -> . empty
    (19) visibility -> . PUBLIC
    (20) visibility -> . PRIVATE
    (21) applicability -> . STATIC

    RBRACE          reduce using rule 1 (empty -> .)
    VOID            reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    BOOLEAN         reduce using rule 1 (empty -> .)
    PUBLIC          shift and go to state 18
    PRIVATE         shift and go to state 19
    STATIC          shift and go to state 20

    class_body_decl                shift and go to state 34
    class_body_sub_decls           shift and go to state 10
    field_decl                     shift and go to state 11
    method_decl                    shift and go to state 12
    constructor_decl               shift and go to state 13
    empty                          shift and go to state 14
    modifier                       shift and go to state 15
    visibility                     shift and go to state 16
    applicability                  shift and go to state 17

state 22

    (5) class_decl -> CLASS ID LBRACE class_body_decl RBRACE .

    CLASS           reduce using rule 5 (class_decl -> CLASS ID LBRACE class_body_decl RBRACE .)
    $end            reduce using rule 5 (class_decl -> CLASS ID LBRACE class_body_decl RBRACE .)


state 23

    (7) class_body_sub_decls -> field_decl SEMICOLON . class_body_sub_decls
    (10) class_body_sub_decls -> field_decl SEMICOLON .
    (7) class_body_sub_decls -> . field_decl SEMICOLON class_body_sub_decls
    (8) class_body_sub_decls -> . method_decl class_body_sub_decls
    (9) class_body_sub_decls -> . constructor_decl class_body_sub_decls
    (10) class_body_sub_decls -> . field_decl SEMICOLON
    (11) class_body_sub_decls -> . constructor_decl
    (12) class_body_sub_decls -> . method_decl
    (13) class_body_sub_decls -> . empty
    (14) field_decl -> . modifier var_decl
    (32) method_decl -> . modifier type ID LPAREN RPAREN block
    (33) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (34) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (35) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (36) constructor_decl -> . modifier ID LPAREN RPAREN block
    (37) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (1) empty -> .
    (15) modifier -> . visibility applicability
    (16) modifier -> . visibility
    (17) modifier -> . applicability
    (18) modifier -> . empty
    (19) visibility -> . PUBLIC
    (20) visibility -> . PRIVATE
    (21) applicability -> . STATIC

  ! reduce/reduce conflict for RBRACE resolved using rule 1 (empty -> .)
    RBRACE          reduce using rule 1 (empty -> .)
    VOID            reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    FLOAT           reduce using rule 1 (empty -> .)
    BOOLEAN         reduce using rule 1 (empty -> .)
    PUBLIC          shift and go to state 18
    PRIVATE         shift and go to state 19
    STATIC          shift and go to state 20

  ! RBRACE          [ reduce using rule 10 (class_body_sub_decls -> field_decl SEMICOLON .) ]

    field_decl                     shift and go to state 11
    class_body_sub_decls           shift and go to state 35
    method_decl                    shift and go to state 12
    constructor_decl               shift and go to state 13
    empty                          shift and go to state 14
    modifier                       shift and go to state 15
    visibility                     shift and go to state 16
    applicability                  shift and go to state 17

state 24

    (8) class_body_sub_decls -> method_decl class_body_sub_decls .

    RBRACE          reduce using rule 8 (class_body_sub_decls -> method_decl class_body_sub_decls .)


state 25

    (9) class_body_sub_decls -> constructor_decl class_body_sub_decls .

    RBRACE          reduce using rule 9 (class_body_sub_decls -> constructor_decl class_body_sub_decls .)


state 26

    (14) field_decl -> modifier var_decl .

    SEMICOLON       reduce using rule 14 (field_decl -> modifier var_decl .)


state 27

    (32) method_decl -> modifier type . ID LPAREN RPAREN block
    (34) method_decl -> modifier type . ID LPAREN formals RPAREN block
    (22) var_decl -> type . variables
    (28) variables -> . variable
    (29) variables -> . variables COMMA variable
    (30) variables -> . empty
    (31) variable -> . ID
    (1) empty -> .

    ID              shift and go to state 36
    COMMA           reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)

    variables                      shift and go to state 37
    variable                       shift and go to state 38
    empty                          shift and go to state 39

state 28

    (36) constructor_decl -> modifier ID . LPAREN RPAREN block
    (37) constructor_decl -> modifier ID . LPAREN formals RPAREN block
    (27) type -> ID .

    LPAREN          shift and go to state 40
    ID              reduce using rule 27 (type -> ID .)
    COMMA           reduce using rule 27 (type -> ID .)
    SEMICOLON       reduce using rule 27 (type -> ID .)


state 29

    (33) method_decl -> modifier VOID . ID LPAREN RPAREN block
    (35) method_decl -> modifier VOID . ID LPAREN formals RPAREN block
    (26) type -> VOID .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 41
    COMMA           reduce using rule 26 (type -> VOID .)
    SEMICOLON       reduce using rule 26 (type -> VOID .)

  ! ID              [ reduce using rule 26 (type -> VOID .) ]


state 30

    (23) type -> INT .

    ID              reduce using rule 23 (type -> INT .)
    COMMA           reduce using rule 23 (type -> INT .)
    SEMICOLON       reduce using rule 23 (type -> INT .)


state 31

    (24) type -> FLOAT .

    ID              reduce using rule 24 (type -> FLOAT .)
    COMMA           reduce using rule 24 (type -> FLOAT .)
    SEMICOLON       reduce using rule 24 (type -> FLOAT .)


state 32

    (25) type -> BOOLEAN .

    ID              reduce using rule 25 (type -> BOOLEAN .)
    COMMA           reduce using rule 25 (type -> BOOLEAN .)
    SEMICOLON       reduce using rule 25 (type -> BOOLEAN .)


state 33

    (15) modifier -> visibility applicability .

    VOID            reduce using rule 15 (modifier -> visibility applicability .)
    ID              reduce using rule 15 (modifier -> visibility applicability .)
    INT             reduce using rule 15 (modifier -> visibility applicability .)
    FLOAT           reduce using rule 15 (modifier -> visibility applicability .)
    BOOLEAN         reduce using rule 15 (modifier -> visibility applicability .)


state 34

    (4) class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl . RBRACE

    RBRACE          shift and go to state 42


state 35

    (7) class_body_sub_decls -> field_decl SEMICOLON class_body_sub_decls .

    RBRACE          reduce using rule 7 (class_body_sub_decls -> field_decl SEMICOLON class_body_sub_decls .)


state 36

    (32) method_decl -> modifier type ID . LPAREN RPAREN block
    (34) method_decl -> modifier type ID . LPAREN formals RPAREN block
    (31) variable -> ID .

    LPAREN          shift and go to state 43
    COMMA           reduce using rule 31 (variable -> ID .)
    SEMICOLON       reduce using rule 31 (variable -> ID .)


state 37

    (22) var_decl -> type variables .
    (29) variables -> variables . COMMA variable

    SEMICOLON       reduce using rule 22 (var_decl -> type variables .)
    COMMA           shift and go to state 44


state 38

    (28) variables -> variable .

    COMMA           reduce using rule 28 (variables -> variable .)
    SEMICOLON       reduce using rule 28 (variables -> variable .)


state 39

    (30) variables -> empty .

    COMMA           reduce using rule 30 (variables -> empty .)
    SEMICOLON       reduce using rule 30 (variables -> empty .)


state 40

    (36) constructor_decl -> modifier ID LPAREN . RPAREN block
    (37) constructor_decl -> modifier ID LPAREN . formals RPAREN block
    (38) formals -> . formals COMMA formal_param
    (39) formals -> . formal_param
    (40) formals -> . empty
    (41) formal_param -> . type variable
    (1) empty -> .
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . BOOLEAN
    (26) type -> . VOID
    (27) type -> . ID

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 46
    COMMA           reduce using rule 1 (empty -> .)
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 51
    ID              shift and go to state 45

  ! RPAREN          [ reduce using rule 1 (empty -> .) ]

    formals                        shift and go to state 47
    formal_param                   shift and go to state 48
    empty                          shift and go to state 49
    type                           shift and go to state 50

state 41

    (33) method_decl -> modifier VOID ID . LPAREN RPAREN block
    (35) method_decl -> modifier VOID ID . LPAREN formals RPAREN block

    LPAREN          shift and go to state 52


state 42

    (4) class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE .

    CLASS           reduce using rule 4 (class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE .)
    $end            reduce using rule 4 (class_decl -> CLASS ID EXTENDS ID LBRACE class_body_decl RBRACE .)


state 43

    (32) method_decl -> modifier type ID LPAREN . RPAREN block
    (34) method_decl -> modifier type ID LPAREN . formals RPAREN block
    (38) formals -> . formals COMMA formal_param
    (39) formals -> . formal_param
    (40) formals -> . empty
    (41) formal_param -> . type variable
    (1) empty -> .
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . BOOLEAN
    (26) type -> . VOID
    (27) type -> . ID

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 53
    COMMA           reduce using rule 1 (empty -> .)
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 51
    ID              shift and go to state 45

  ! RPAREN          [ reduce using rule 1 (empty -> .) ]

    type                           shift and go to state 50
    formals                        shift and go to state 54
    formal_param                   shift and go to state 48
    empty                          shift and go to state 49

state 44

    (29) variables -> variables COMMA . variable
    (31) variable -> . ID

    ID              shift and go to state 56

    variable                       shift and go to state 55

state 45

    (27) type -> ID .

    ID              reduce using rule 27 (type -> ID .)


state 46

    (36) constructor_decl -> modifier ID LPAREN RPAREN . block
    (42) block -> . LBRACE block_end RBRACE

    LBRACE          shift and go to state 58

    block                          shift and go to state 57

state 47

    (37) constructor_decl -> modifier ID LPAREN formals . RPAREN block
    (38) formals -> formals . COMMA formal_param

    RPAREN          shift and go to state 59
    COMMA           shift and go to state 60


state 48

    (39) formals -> formal_param .

    RPAREN          reduce using rule 39 (formals -> formal_param .)
    COMMA           reduce using rule 39 (formals -> formal_param .)


state 49

    (40) formals -> empty .

    RPAREN          reduce using rule 40 (formals -> empty .)
    COMMA           reduce using rule 40 (formals -> empty .)


state 50

    (41) formal_param -> type . variable
    (31) variable -> . ID

    ID              shift and go to state 56

    variable                       shift and go to state 61

state 51

    (26) type -> VOID .

    ID              reduce using rule 26 (type -> VOID .)
    COMMA           reduce using rule 26 (type -> VOID .)
    SEMICOLON       reduce using rule 26 (type -> VOID .)


state 52

    (33) method_decl -> modifier VOID ID LPAREN . RPAREN block
    (35) method_decl -> modifier VOID ID LPAREN . formals RPAREN block
    (38) formals -> . formals COMMA formal_param
    (39) formals -> . formal_param
    (40) formals -> . empty
    (41) formal_param -> . type variable
    (1) empty -> .
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . BOOLEAN
    (26) type -> . VOID
    (27) type -> . ID

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 62
    COMMA           reduce using rule 1 (empty -> .)
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 51
    ID              shift and go to state 45

  ! RPAREN          [ reduce using rule 1 (empty -> .) ]

    formals                        shift and go to state 63
    formal_param                   shift and go to state 48
    empty                          shift and go to state 49
    type                           shift and go to state 50

state 53

    (32) method_decl -> modifier type ID LPAREN RPAREN . block
    (42) block -> . LBRACE block_end RBRACE

    LBRACE          shift and go to state 58

    block                          shift and go to state 64

state 54

    (34) method_decl -> modifier type ID LPAREN formals . RPAREN block
    (38) formals -> formals . COMMA formal_param

    RPAREN          shift and go to state 65
    COMMA           shift and go to state 60


state 55

    (29) variables -> variables COMMA variable .

    COMMA           reduce using rule 29 (variables -> variables COMMA variable .)
    SEMICOLON       reduce using rule 29 (variables -> variables COMMA variable .)


state 56

    (31) variable -> ID .

    COMMA           reduce using rule 31 (variable -> ID .)
    SEMICOLON       reduce using rule 31 (variable -> ID .)
    RPAREN          reduce using rule 31 (variable -> ID .)


state 57

    (36) constructor_decl -> modifier ID LPAREN RPAREN block .

    PUBLIC          reduce using rule 36 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 36 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    STATIC          reduce using rule 36 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    VOID            reduce using rule 36 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    ID              reduce using rule 36 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    INT             reduce using rule 36 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 36 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 36 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    RBRACE          reduce using rule 36 (constructor_decl -> modifier ID LPAREN RPAREN block .)


state 58

    (42) block -> LBRACE . block_end RBRACE
    (43) block_end -> . stmt
    (44) block_end -> . stmt block_end
    (45) block_end -> . empty
    (46) stmt -> . IF LPAREN expr RPAREN stmt
    (47) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (48) stmt -> . WHILE LPAREN expr RPAREN stmt
    (49) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl SEMICOLON
    (57) stmt -> . SEMICOLON
    (1) empty -> .
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (42) block -> . LBRACE block_end RBRACE
    (22) var_decl -> . type variables
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . BOOLEAN
    (26) type -> . VOID
    (27) type -> . ID
    (75) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE

    IF              shift and go to state 69
    WHILE           shift and go to state 71
    FOR             shift and go to state 72
    RETURN          shift and go to state 75
    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 74
    RBRACE          reduce using rule 1 (empty -> .)
    LBRACE          shift and go to state 58
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 51
    ID              shift and go to state 87
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    block_end                      shift and go to state 66
    stmt                           shift and go to state 67
    empty                          shift and go to state 68
    stmt_expr                      shift and go to state 73
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    type                           shift and go to state 82
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 59

    (37) constructor_decl -> modifier ID LPAREN formals RPAREN . block
    (42) block -> . LBRACE block_end RBRACE

    LBRACE          shift and go to state 58

    block                          shift and go to state 99

state 60

    (38) formals -> formals COMMA . formal_param
    (41) formal_param -> . type variable
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . BOOLEAN
    (26) type -> . VOID
    (27) type -> . ID

    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 51
    ID              shift and go to state 45

    formal_param                   shift and go to state 100
    type                           shift and go to state 50

state 61

    (41) formal_param -> type variable .

    RPAREN          reduce using rule 41 (formal_param -> type variable .)
    COMMA           reduce using rule 41 (formal_param -> type variable .)


state 62

    (33) method_decl -> modifier VOID ID LPAREN RPAREN . block
    (42) block -> . LBRACE block_end RBRACE

    LBRACE          shift and go to state 58

    block                          shift and go to state 101

state 63

    (35) method_decl -> modifier VOID ID LPAREN formals . RPAREN block
    (38) formals -> formals . COMMA formal_param

    RPAREN          shift and go to state 102
    COMMA           shift and go to state 60


state 64

    (32) method_decl -> modifier type ID LPAREN RPAREN block .

    PUBLIC          reduce using rule 32 (method_decl -> modifier type ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 32 (method_decl -> modifier type ID LPAREN RPAREN block .)
    STATIC          reduce using rule 32 (method_decl -> modifier type ID LPAREN RPAREN block .)
    VOID            reduce using rule 32 (method_decl -> modifier type ID LPAREN RPAREN block .)
    ID              reduce using rule 32 (method_decl -> modifier type ID LPAREN RPAREN block .)
    INT             reduce using rule 32 (method_decl -> modifier type ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 32 (method_decl -> modifier type ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 32 (method_decl -> modifier type ID LPAREN RPAREN block .)
    RBRACE          reduce using rule 32 (method_decl -> modifier type ID LPAREN RPAREN block .)


state 65

    (34) method_decl -> modifier type ID LPAREN formals RPAREN . block
    (42) block -> . LBRACE block_end RBRACE

    LBRACE          shift and go to state 58

    block                          shift and go to state 103

state 66

    (42) block -> LBRACE block_end . RBRACE

    RBRACE          shift and go to state 104


state 67

    (43) block_end -> stmt .
    (44) block_end -> stmt . block_end
    (43) block_end -> . stmt
    (44) block_end -> . stmt block_end
    (45) block_end -> . empty
    (46) stmt -> . IF LPAREN expr RPAREN stmt
    (47) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (48) stmt -> . WHILE LPAREN expr RPAREN stmt
    (49) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl SEMICOLON
    (57) stmt -> . SEMICOLON
    (1) empty -> .
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (42) block -> . LBRACE block_end RBRACE
    (22) var_decl -> . type variables
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . BOOLEAN
    (26) type -> . VOID
    (27) type -> . ID
    (75) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE

  ! reduce/reduce conflict for RBRACE resolved using rule 1 (empty -> .)
    IF              shift and go to state 69
    WHILE           shift and go to state 71
    FOR             shift and go to state 72
    RETURN          shift and go to state 75
    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 74
    RBRACE          reduce using rule 1 (empty -> .)
    LBRACE          shift and go to state 58
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 51
    ID              shift and go to state 87
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

  ! RBRACE          [ reduce using rule 43 (block_end -> stmt .) ]

    stmt                           shift and go to state 67
    block_end                      shift and go to state 105
    empty                          shift and go to state 68
    stmt_expr                      shift and go to state 73
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    type                           shift and go to state 82
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 68

    (45) block_end -> empty .

    RBRACE          reduce using rule 45 (block_end -> empty .)


state 69

    (46) stmt -> IF . LPAREN expr RPAREN stmt
    (47) stmt -> IF . LPAREN expr RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 106


state 70

    (67) primary -> LPAREN . expr RPAREN
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (75) lhs -> . field_access
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    NOT             shift and go to state 116
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 111

    expr                           shift and go to state 107
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    unary_op                       shift and go to state 110
    literal                        shift and go to state 89
    lhs                            shift and go to state 112
    method_invocation              shift and go to state 113
    field_access                   shift and go to state 117

state 71

    (48) stmt -> WHILE . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 118


state 72

    (49) stmt -> FOR . LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt

    LPAREN          shift and go to state 119


state 73

    (52) stmt -> stmt_expr . SEMICOLON

    SEMICOLON       shift and go to state 120


state 74

    (57) stmt -> SEMICOLON .

    IF              reduce using rule 57 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 57 (stmt -> SEMICOLON .)
    FOR             reduce using rule 57 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 57 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 57 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 57 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 57 (stmt -> SEMICOLON .)
    LBRACE          reduce using rule 57 (stmt -> SEMICOLON .)
    PLUSPLUS        reduce using rule 57 (stmt -> SEMICOLON .)
    MINUSMINUS      reduce using rule 57 (stmt -> SEMICOLON .)
    INT             reduce using rule 57 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 57 (stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 57 (stmt -> SEMICOLON .)
    VOID            reduce using rule 57 (stmt -> SEMICOLON .)
    ID              reduce using rule 57 (stmt -> SEMICOLON .)
    THIS            reduce using rule 57 (stmt -> SEMICOLON .)
    SUPER           reduce using rule 57 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 57 (stmt -> SEMICOLON .)
    NEW             reduce using rule 57 (stmt -> SEMICOLON .)
    INTCONST        reduce using rule 57 (stmt -> SEMICOLON .)
    FLOATCONST      reduce using rule 57 (stmt -> SEMICOLON .)
    STRINGCONST     reduce using rule 57 (stmt -> SEMICOLON .)
    NULL            reduce using rule 57 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 57 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 57 (stmt -> SEMICOLON .)
    RBRACE          reduce using rule 57 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 57 (stmt -> SEMICOLON .)


state 75

    (50) stmt -> RETURN . SEMICOLON
    (51) stmt -> RETURN . expr SEMICOLON
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (75) lhs -> . field_access
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    SEMICOLON       shift and go to state 121
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    NOT             shift and go to state 116
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 111

    expr                           shift and go to state 122
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    unary_op                       shift and go to state 110
    literal                        shift and go to state 89
    lhs                            shift and go to state 112
    method_invocation              shift and go to state 113
    field_access                   shift and go to state 117

state 76

    (53) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 123


state 77

    (54) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 124


state 78

    (55) stmt -> block .

    IF              reduce using rule 55 (stmt -> block .)
    WHILE           reduce using rule 55 (stmt -> block .)
    FOR             reduce using rule 55 (stmt -> block .)
    RETURN          reduce using rule 55 (stmt -> block .)
    BREAK           reduce using rule 55 (stmt -> block .)
    CONTINUE        reduce using rule 55 (stmt -> block .)
    SEMICOLON       reduce using rule 55 (stmt -> block .)
    LBRACE          reduce using rule 55 (stmt -> block .)
    PLUSPLUS        reduce using rule 55 (stmt -> block .)
    MINUSMINUS      reduce using rule 55 (stmt -> block .)
    INT             reduce using rule 55 (stmt -> block .)
    FLOAT           reduce using rule 55 (stmt -> block .)
    BOOLEAN         reduce using rule 55 (stmt -> block .)
    VOID            reduce using rule 55 (stmt -> block .)
    ID              reduce using rule 55 (stmt -> block .)
    THIS            reduce using rule 55 (stmt -> block .)
    SUPER           reduce using rule 55 (stmt -> block .)
    LPAREN          reduce using rule 55 (stmt -> block .)
    NEW             reduce using rule 55 (stmt -> block .)
    INTCONST        reduce using rule 55 (stmt -> block .)
    FLOATCONST      reduce using rule 55 (stmt -> block .)
    STRINGCONST     reduce using rule 55 (stmt -> block .)
    NULL            reduce using rule 55 (stmt -> block .)
    TRUE            reduce using rule 55 (stmt -> block .)
    FALSE           reduce using rule 55 (stmt -> block .)
    RBRACE          reduce using rule 55 (stmt -> block .)
    ELSE            reduce using rule 55 (stmt -> block .)


state 79

    (56) stmt -> var_decl . SEMICOLON

    SEMICOLON       shift and go to state 125


state 80

    (105) stmt_expr -> assign .

    SEMICOLON       reduce using rule 105 (stmt_expr -> assign .)
    RPAREN          reduce using rule 105 (stmt_expr -> assign .)


state 81

    (106) stmt_expr -> method_invocation .
    (71) primary -> method_invocation .

    SEMICOLON       reduce using rule 106 (stmt_expr -> method_invocation .)
    RPAREN          reduce using rule 106 (stmt_expr -> method_invocation .)
    PERIOD          reduce using rule 71 (primary -> method_invocation .)


state 82

    (22) var_decl -> type . variables
    (28) variables -> . variable
    (29) variables -> . variables COMMA variable
    (30) variables -> . empty
    (31) variable -> . ID
    (1) empty -> .

    ID              shift and go to state 56
    COMMA           reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)

    variables                      shift and go to state 37
    variable                       shift and go to state 38
    empty                          shift and go to state 39

state 83

    (85) assign -> lhs . EQUALS expr
    (86) assign -> lhs . PLUSPLUS
    (88) assign -> lhs . MINUSMINUS
    (70) primary -> lhs .

    EQUALS          shift and go to state 126
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128
    PERIOD          reduce using rule 70 (primary -> lhs .)


state 84

    (87) assign -> PLUSPLUS . lhs
    (75) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN

    ID              shift and go to state 111
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    lhs                            shift and go to state 129
    field_access                   shift and go to state 117
    primary                        shift and go to state 88
    literal                        shift and go to state 89
    method_invocation              shift and go to state 113

state 85

    (89) assign -> MINUSMINUS . lhs
    (75) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN

    ID              shift and go to state 111
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    lhs                            shift and go to state 130
    field_access                   shift and go to state 117
    primary                        shift and go to state 88
    literal                        shift and go to state 89
    method_invocation              shift and go to state 113

state 86

    (76) method_invocation -> field_access . LPAREN RPAREN
    (77) method_invocation -> field_access . LPAREN arguments RPAREN
    (75) lhs -> field_access .

    LPAREN          shift and go to state 131
    EQUALS          reduce using rule 75 (lhs -> field_access .)
    PLUSPLUS        reduce using rule 75 (lhs -> field_access .)
    MINUSMINUS      reduce using rule 75 (lhs -> field_access .)
    PERIOD          reduce using rule 75 (lhs -> field_access .)


state 87

    (27) type -> ID .
    (79) field_access -> ID .

    ID              reduce using rule 27 (type -> ID .)
    COMMA           reduce using rule 27 (type -> ID .)
    SEMICOLON       reduce using rule 27 (type -> ID .)
    LPAREN          reduce using rule 79 (field_access -> ID .)
    EQUALS          reduce using rule 79 (field_access -> ID .)
    PLUSPLUS        reduce using rule 79 (field_access -> ID .)
    MINUSMINUS      reduce using rule 79 (field_access -> ID .)
    PERIOD          reduce using rule 79 (field_access -> ID .)


state 88

    (78) field_access -> primary . PERIOD ID

    PERIOD          shift and go to state 132


state 89

    (64) primary -> literal .

    PERIOD          reduce using rule 64 (primary -> literal .)
    RPAREN          reduce using rule 64 (primary -> literal .)
    PLUS            reduce using rule 64 (primary -> literal .)
    MINUS           reduce using rule 64 (primary -> literal .)
    TIMES           reduce using rule 64 (primary -> literal .)
    DIVIDE          reduce using rule 64 (primary -> literal .)
    AND             reduce using rule 64 (primary -> literal .)
    OR              reduce using rule 64 (primary -> literal .)
    EQUALSCOMPARE   reduce using rule 64 (primary -> literal .)
    NOTEQUALS       reduce using rule 64 (primary -> literal .)
    LESSTHAN        reduce using rule 64 (primary -> literal .)
    GREATERTHAN     reduce using rule 64 (primary -> literal .)
    LESSTHANOREQ    reduce using rule 64 (primary -> literal .)
    GREATERTHANOREQ reduce using rule 64 (primary -> literal .)
    SEMICOLON       reduce using rule 64 (primary -> literal .)
    COMMA           reduce using rule 64 (primary -> literal .)


state 90

    (65) primary -> THIS .

    PERIOD          reduce using rule 65 (primary -> THIS .)
    RPAREN          reduce using rule 65 (primary -> THIS .)
    PLUS            reduce using rule 65 (primary -> THIS .)
    MINUS           reduce using rule 65 (primary -> THIS .)
    TIMES           reduce using rule 65 (primary -> THIS .)
    DIVIDE          reduce using rule 65 (primary -> THIS .)
    AND             reduce using rule 65 (primary -> THIS .)
    OR              reduce using rule 65 (primary -> THIS .)
    EQUALSCOMPARE   reduce using rule 65 (primary -> THIS .)
    NOTEQUALS       reduce using rule 65 (primary -> THIS .)
    LESSTHAN        reduce using rule 65 (primary -> THIS .)
    GREATERTHAN     reduce using rule 65 (primary -> THIS .)
    LESSTHANOREQ    reduce using rule 65 (primary -> THIS .)
    GREATERTHANOREQ reduce using rule 65 (primary -> THIS .)
    SEMICOLON       reduce using rule 65 (primary -> THIS .)
    COMMA           reduce using rule 65 (primary -> THIS .)


state 91

    (66) primary -> SUPER .

    PERIOD          reduce using rule 66 (primary -> SUPER .)
    RPAREN          reduce using rule 66 (primary -> SUPER .)
    PLUS            reduce using rule 66 (primary -> SUPER .)
    MINUS           reduce using rule 66 (primary -> SUPER .)
    TIMES           reduce using rule 66 (primary -> SUPER .)
    DIVIDE          reduce using rule 66 (primary -> SUPER .)
    AND             reduce using rule 66 (primary -> SUPER .)
    OR              reduce using rule 66 (primary -> SUPER .)
    EQUALSCOMPARE   reduce using rule 66 (primary -> SUPER .)
    NOTEQUALS       reduce using rule 66 (primary -> SUPER .)
    LESSTHAN        reduce using rule 66 (primary -> SUPER .)
    GREATERTHAN     reduce using rule 66 (primary -> SUPER .)
    LESSTHANOREQ    reduce using rule 66 (primary -> SUPER .)
    GREATERTHANOREQ reduce using rule 66 (primary -> SUPER .)
    SEMICOLON       reduce using rule 66 (primary -> SUPER .)
    COMMA           reduce using rule 66 (primary -> SUPER .)


state 92

    (68) primary -> NEW . ID LPAREN arguments RPAREN
    (69) primary -> NEW . ID LPAREN RPAREN

    ID              shift and go to state 133


state 93

    (58) literal -> INTCONST .

    PERIOD          reduce using rule 58 (literal -> INTCONST .)
    RPAREN          reduce using rule 58 (literal -> INTCONST .)
    PLUS            reduce using rule 58 (literal -> INTCONST .)
    MINUS           reduce using rule 58 (literal -> INTCONST .)
    TIMES           reduce using rule 58 (literal -> INTCONST .)
    DIVIDE          reduce using rule 58 (literal -> INTCONST .)
    AND             reduce using rule 58 (literal -> INTCONST .)
    OR              reduce using rule 58 (literal -> INTCONST .)
    EQUALSCOMPARE   reduce using rule 58 (literal -> INTCONST .)
    NOTEQUALS       reduce using rule 58 (literal -> INTCONST .)
    LESSTHAN        reduce using rule 58 (literal -> INTCONST .)
    GREATERTHAN     reduce using rule 58 (literal -> INTCONST .)
    LESSTHANOREQ    reduce using rule 58 (literal -> INTCONST .)
    GREATERTHANOREQ reduce using rule 58 (literal -> INTCONST .)
    SEMICOLON       reduce using rule 58 (literal -> INTCONST .)
    COMMA           reduce using rule 58 (literal -> INTCONST .)


state 94

    (59) literal -> FLOATCONST .

    PERIOD          reduce using rule 59 (literal -> FLOATCONST .)
    RPAREN          reduce using rule 59 (literal -> FLOATCONST .)
    PLUS            reduce using rule 59 (literal -> FLOATCONST .)
    MINUS           reduce using rule 59 (literal -> FLOATCONST .)
    TIMES           reduce using rule 59 (literal -> FLOATCONST .)
    DIVIDE          reduce using rule 59 (literal -> FLOATCONST .)
    AND             reduce using rule 59 (literal -> FLOATCONST .)
    OR              reduce using rule 59 (literal -> FLOATCONST .)
    EQUALSCOMPARE   reduce using rule 59 (literal -> FLOATCONST .)
    NOTEQUALS       reduce using rule 59 (literal -> FLOATCONST .)
    LESSTHAN        reduce using rule 59 (literal -> FLOATCONST .)
    GREATERTHAN     reduce using rule 59 (literal -> FLOATCONST .)
    LESSTHANOREQ    reduce using rule 59 (literal -> FLOATCONST .)
    GREATERTHANOREQ reduce using rule 59 (literal -> FLOATCONST .)
    SEMICOLON       reduce using rule 59 (literal -> FLOATCONST .)
    COMMA           reduce using rule 59 (literal -> FLOATCONST .)


state 95

    (60) literal -> STRINGCONST .

    PERIOD          reduce using rule 60 (literal -> STRINGCONST .)
    RPAREN          reduce using rule 60 (literal -> STRINGCONST .)
    PLUS            reduce using rule 60 (literal -> STRINGCONST .)
    MINUS           reduce using rule 60 (literal -> STRINGCONST .)
    TIMES           reduce using rule 60 (literal -> STRINGCONST .)
    DIVIDE          reduce using rule 60 (literal -> STRINGCONST .)
    AND             reduce using rule 60 (literal -> STRINGCONST .)
    OR              reduce using rule 60 (literal -> STRINGCONST .)
    EQUALSCOMPARE   reduce using rule 60 (literal -> STRINGCONST .)
    NOTEQUALS       reduce using rule 60 (literal -> STRINGCONST .)
    LESSTHAN        reduce using rule 60 (literal -> STRINGCONST .)
    GREATERTHAN     reduce using rule 60 (literal -> STRINGCONST .)
    LESSTHANOREQ    reduce using rule 60 (literal -> STRINGCONST .)
    GREATERTHANOREQ reduce using rule 60 (literal -> STRINGCONST .)
    SEMICOLON       reduce using rule 60 (literal -> STRINGCONST .)
    COMMA           reduce using rule 60 (literal -> STRINGCONST .)


state 96

    (61) literal -> NULL .

    PERIOD          reduce using rule 61 (literal -> NULL .)
    RPAREN          reduce using rule 61 (literal -> NULL .)
    PLUS            reduce using rule 61 (literal -> NULL .)
    MINUS           reduce using rule 61 (literal -> NULL .)
    TIMES           reduce using rule 61 (literal -> NULL .)
    DIVIDE          reduce using rule 61 (literal -> NULL .)
    AND             reduce using rule 61 (literal -> NULL .)
    OR              reduce using rule 61 (literal -> NULL .)
    EQUALSCOMPARE   reduce using rule 61 (literal -> NULL .)
    NOTEQUALS       reduce using rule 61 (literal -> NULL .)
    LESSTHAN        reduce using rule 61 (literal -> NULL .)
    GREATERTHAN     reduce using rule 61 (literal -> NULL .)
    LESSTHANOREQ    reduce using rule 61 (literal -> NULL .)
    GREATERTHANOREQ reduce using rule 61 (literal -> NULL .)
    SEMICOLON       reduce using rule 61 (literal -> NULL .)
    COMMA           reduce using rule 61 (literal -> NULL .)


state 97

    (62) literal -> TRUE .

    PERIOD          reduce using rule 62 (literal -> TRUE .)
    RPAREN          reduce using rule 62 (literal -> TRUE .)
    PLUS            reduce using rule 62 (literal -> TRUE .)
    MINUS           reduce using rule 62 (literal -> TRUE .)
    TIMES           reduce using rule 62 (literal -> TRUE .)
    DIVIDE          reduce using rule 62 (literal -> TRUE .)
    AND             reduce using rule 62 (literal -> TRUE .)
    OR              reduce using rule 62 (literal -> TRUE .)
    EQUALSCOMPARE   reduce using rule 62 (literal -> TRUE .)
    NOTEQUALS       reduce using rule 62 (literal -> TRUE .)
    LESSTHAN        reduce using rule 62 (literal -> TRUE .)
    GREATERTHAN     reduce using rule 62 (literal -> TRUE .)
    LESSTHANOREQ    reduce using rule 62 (literal -> TRUE .)
    GREATERTHANOREQ reduce using rule 62 (literal -> TRUE .)
    SEMICOLON       reduce using rule 62 (literal -> TRUE .)
    COMMA           reduce using rule 62 (literal -> TRUE .)


state 98

    (63) literal -> FALSE .

    PERIOD          reduce using rule 63 (literal -> FALSE .)
    RPAREN          reduce using rule 63 (literal -> FALSE .)
    PLUS            reduce using rule 63 (literal -> FALSE .)
    MINUS           reduce using rule 63 (literal -> FALSE .)
    TIMES           reduce using rule 63 (literal -> FALSE .)
    DIVIDE          reduce using rule 63 (literal -> FALSE .)
    AND             reduce using rule 63 (literal -> FALSE .)
    OR              reduce using rule 63 (literal -> FALSE .)
    EQUALSCOMPARE   reduce using rule 63 (literal -> FALSE .)
    NOTEQUALS       reduce using rule 63 (literal -> FALSE .)
    LESSTHAN        reduce using rule 63 (literal -> FALSE .)
    GREATERTHAN     reduce using rule 63 (literal -> FALSE .)
    LESSTHANOREQ    reduce using rule 63 (literal -> FALSE .)
    GREATERTHANOREQ reduce using rule 63 (literal -> FALSE .)
    SEMICOLON       reduce using rule 63 (literal -> FALSE .)
    COMMA           reduce using rule 63 (literal -> FALSE .)


state 99

    (37) constructor_decl -> modifier ID LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 37 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 37 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 37 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 37 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    ID              reduce using rule 37 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    INT             reduce using rule 37 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 37 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 37 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    RBRACE          reduce using rule 37 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)


state 100

    (38) formals -> formals COMMA formal_param .

    RPAREN          reduce using rule 38 (formals -> formals COMMA formal_param .)
    COMMA           reduce using rule 38 (formals -> formals COMMA formal_param .)


state 101

    (33) method_decl -> modifier VOID ID LPAREN RPAREN block .

    PUBLIC          reduce using rule 33 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 33 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    STATIC          reduce using rule 33 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    VOID            reduce using rule 33 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    ID              reduce using rule 33 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    INT             reduce using rule 33 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 33 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 33 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    RBRACE          reduce using rule 33 (method_decl -> modifier VOID ID LPAREN RPAREN block .)


state 102

    (35) method_decl -> modifier VOID ID LPAREN formals RPAREN . block
    (42) block -> . LBRACE block_end RBRACE

    LBRACE          shift and go to state 58

    block                          shift and go to state 134

state 103

    (34) method_decl -> modifier type ID LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 34 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 34 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 34 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 34 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    ID              reduce using rule 34 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    INT             reduce using rule 34 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 34 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 34 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    RBRACE          reduce using rule 34 (method_decl -> modifier type ID LPAREN formals RPAREN block .)


state 104

    (42) block -> LBRACE block_end RBRACE .

    PUBLIC          reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    PRIVATE         reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    STATIC          reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    VOID            reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    ID              reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    INT             reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    FLOAT           reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    BOOLEAN         reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    RBRACE          reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    IF              reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    WHILE           reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    FOR             reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    RETURN          reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    BREAK           reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    CONTINUE        reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    SEMICOLON       reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    LBRACE          reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    PLUSPLUS        reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    MINUSMINUS      reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    THIS            reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    SUPER           reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    LPAREN          reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    NEW             reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    INTCONST        reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    FLOATCONST      reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    STRINGCONST     reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    NULL            reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    TRUE            reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    FALSE           reduce using rule 42 (block -> LBRACE block_end RBRACE .)
    ELSE            reduce using rule 42 (block -> LBRACE block_end RBRACE .)


state 105

    (44) block_end -> stmt block_end .

    RBRACE          reduce using rule 44 (block_end -> stmt block_end .)


state 106

    (46) stmt -> IF LPAREN . expr RPAREN stmt
    (47) stmt -> IF LPAREN . expr RPAREN stmt ELSE stmt
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (75) lhs -> . field_access
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    NOT             shift and go to state 116
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 111

    expr                           shift and go to state 135
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    unary_op                       shift and go to state 110
    literal                        shift and go to state 89
    lhs                            shift and go to state 112
    method_invocation              shift and go to state 113
    field_access                   shift and go to state 117

state 107

    (67) primary -> LPAREN expr . RPAREN
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQUALSCOMPARE
    (97) bool_op -> . NOTEQUALS
    (98) bool_op -> . LESSTHAN
    (99) bool_op -> . GREATERTHAN
    (100) bool_op -> . LESSTHANOREQ
    (101) bool_op -> . GREATERTHANOREQ

    RPAREN          shift and go to state 136
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUALSCOMPARE   shift and go to state 145
    NOTEQUALS       shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LESSTHANOREQ    shift and go to state 149
    GREATERTHANOREQ shift and go to state 150

    arith_op                       shift and go to state 137
    bool_op                        shift and go to state 138

state 108

    (80) expr -> primary .
    (78) field_access -> primary . PERIOD ID

    RPAREN          reduce using rule 80 (expr -> primary .)
    PLUS            reduce using rule 80 (expr -> primary .)
    MINUS           reduce using rule 80 (expr -> primary .)
    TIMES           reduce using rule 80 (expr -> primary .)
    DIVIDE          reduce using rule 80 (expr -> primary .)
    AND             reduce using rule 80 (expr -> primary .)
    OR              reduce using rule 80 (expr -> primary .)
    EQUALSCOMPARE   reduce using rule 80 (expr -> primary .)
    NOTEQUALS       reduce using rule 80 (expr -> primary .)
    LESSTHAN        reduce using rule 80 (expr -> primary .)
    GREATERTHAN     reduce using rule 80 (expr -> primary .)
    LESSTHANOREQ    reduce using rule 80 (expr -> primary .)
    GREATERTHANOREQ reduce using rule 80 (expr -> primary .)
    SEMICOLON       reduce using rule 80 (expr -> primary .)
    COMMA           reduce using rule 80 (expr -> primary .)
    PERIOD          shift and go to state 132


state 109

    (81) expr -> assign .

    RPAREN          reduce using rule 81 (expr -> assign .)
    PLUS            reduce using rule 81 (expr -> assign .)
    MINUS           reduce using rule 81 (expr -> assign .)
    TIMES           reduce using rule 81 (expr -> assign .)
    DIVIDE          reduce using rule 81 (expr -> assign .)
    AND             reduce using rule 81 (expr -> assign .)
    OR              reduce using rule 81 (expr -> assign .)
    EQUALSCOMPARE   reduce using rule 81 (expr -> assign .)
    NOTEQUALS       reduce using rule 81 (expr -> assign .)
    LESSTHAN        reduce using rule 81 (expr -> assign .)
    GREATERTHAN     reduce using rule 81 (expr -> assign .)
    LESSTHANOREQ    reduce using rule 81 (expr -> assign .)
    GREATERTHANOREQ reduce using rule 81 (expr -> assign .)
    SEMICOLON       reduce using rule 81 (expr -> assign .)
    COMMA           reduce using rule 81 (expr -> assign .)


state 110

    (84) expr -> unary_op . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (75) lhs -> . field_access
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    NOT             shift and go to state 116
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 111

    unary_op                       shift and go to state 110
    expr                           shift and go to state 151
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    literal                        shift and go to state 89
    lhs                            shift and go to state 112
    method_invocation              shift and go to state 113
    field_access                   shift and go to state 117

state 111

    (79) field_access -> ID .

    LPAREN          reduce using rule 79 (field_access -> ID .)
    EQUALS          reduce using rule 79 (field_access -> ID .)
    PLUSPLUS        reduce using rule 79 (field_access -> ID .)
    MINUSMINUS      reduce using rule 79 (field_access -> ID .)
    PERIOD          reduce using rule 79 (field_access -> ID .)
    RPAREN          reduce using rule 79 (field_access -> ID .)
    PLUS            reduce using rule 79 (field_access -> ID .)
    MINUS           reduce using rule 79 (field_access -> ID .)
    TIMES           reduce using rule 79 (field_access -> ID .)
    DIVIDE          reduce using rule 79 (field_access -> ID .)
    AND             reduce using rule 79 (field_access -> ID .)
    OR              reduce using rule 79 (field_access -> ID .)
    EQUALSCOMPARE   reduce using rule 79 (field_access -> ID .)
    NOTEQUALS       reduce using rule 79 (field_access -> ID .)
    LESSTHAN        reduce using rule 79 (field_access -> ID .)
    GREATERTHAN     reduce using rule 79 (field_access -> ID .)
    LESSTHANOREQ    reduce using rule 79 (field_access -> ID .)
    GREATERTHANOREQ reduce using rule 79 (field_access -> ID .)
    SEMICOLON       reduce using rule 79 (field_access -> ID .)
    COMMA           reduce using rule 79 (field_access -> ID .)


state 112

    (70) primary -> lhs .
    (85) assign -> lhs . EQUALS expr
    (86) assign -> lhs . PLUSPLUS
    (88) assign -> lhs . MINUSMINUS

    PERIOD          reduce using rule 70 (primary -> lhs .)
    RPAREN          reduce using rule 70 (primary -> lhs .)
    PLUS            reduce using rule 70 (primary -> lhs .)
    MINUS           reduce using rule 70 (primary -> lhs .)
    TIMES           reduce using rule 70 (primary -> lhs .)
    DIVIDE          reduce using rule 70 (primary -> lhs .)
    AND             reduce using rule 70 (primary -> lhs .)
    OR              reduce using rule 70 (primary -> lhs .)
    EQUALSCOMPARE   reduce using rule 70 (primary -> lhs .)
    NOTEQUALS       reduce using rule 70 (primary -> lhs .)
    LESSTHAN        reduce using rule 70 (primary -> lhs .)
    GREATERTHAN     reduce using rule 70 (primary -> lhs .)
    LESSTHANOREQ    reduce using rule 70 (primary -> lhs .)
    GREATERTHANOREQ reduce using rule 70 (primary -> lhs .)
    SEMICOLON       reduce using rule 70 (primary -> lhs .)
    COMMA           reduce using rule 70 (primary -> lhs .)
    EQUALS          shift and go to state 126
    PLUSPLUS        shift and go to state 127
    MINUSMINUS      shift and go to state 128


state 113

    (71) primary -> method_invocation .

    PERIOD          reduce using rule 71 (primary -> method_invocation .)
    RPAREN          reduce using rule 71 (primary -> method_invocation .)
    PLUS            reduce using rule 71 (primary -> method_invocation .)
    MINUS           reduce using rule 71 (primary -> method_invocation .)
    TIMES           reduce using rule 71 (primary -> method_invocation .)
    DIVIDE          reduce using rule 71 (primary -> method_invocation .)
    AND             reduce using rule 71 (primary -> method_invocation .)
    OR              reduce using rule 71 (primary -> method_invocation .)
    EQUALSCOMPARE   reduce using rule 71 (primary -> method_invocation .)
    NOTEQUALS       reduce using rule 71 (primary -> method_invocation .)
    LESSTHAN        reduce using rule 71 (primary -> method_invocation .)
    GREATERTHAN     reduce using rule 71 (primary -> method_invocation .)
    LESSTHANOREQ    reduce using rule 71 (primary -> method_invocation .)
    GREATERTHANOREQ reduce using rule 71 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 71 (primary -> method_invocation .)
    COMMA           reduce using rule 71 (primary -> method_invocation .)


state 114

    (102) unary_op -> PLUS .

    THIS            reduce using rule 102 (unary_op -> PLUS .)
    SUPER           reduce using rule 102 (unary_op -> PLUS .)
    LPAREN          reduce using rule 102 (unary_op -> PLUS .)
    NEW             reduce using rule 102 (unary_op -> PLUS .)
    PLUSPLUS        reduce using rule 102 (unary_op -> PLUS .)
    MINUSMINUS      reduce using rule 102 (unary_op -> PLUS .)
    PLUS            reduce using rule 102 (unary_op -> PLUS .)
    MINUS           reduce using rule 102 (unary_op -> PLUS .)
    NOT             reduce using rule 102 (unary_op -> PLUS .)
    INTCONST        reduce using rule 102 (unary_op -> PLUS .)
    FLOATCONST      reduce using rule 102 (unary_op -> PLUS .)
    STRINGCONST     reduce using rule 102 (unary_op -> PLUS .)
    NULL            reduce using rule 102 (unary_op -> PLUS .)
    TRUE            reduce using rule 102 (unary_op -> PLUS .)
    FALSE           reduce using rule 102 (unary_op -> PLUS .)
    ID              reduce using rule 102 (unary_op -> PLUS .)


state 115

    (103) unary_op -> MINUS .

    THIS            reduce using rule 103 (unary_op -> MINUS .)
    SUPER           reduce using rule 103 (unary_op -> MINUS .)
    LPAREN          reduce using rule 103 (unary_op -> MINUS .)
    NEW             reduce using rule 103 (unary_op -> MINUS .)
    PLUSPLUS        reduce using rule 103 (unary_op -> MINUS .)
    MINUSMINUS      reduce using rule 103 (unary_op -> MINUS .)
    PLUS            reduce using rule 103 (unary_op -> MINUS .)
    MINUS           reduce using rule 103 (unary_op -> MINUS .)
    NOT             reduce using rule 103 (unary_op -> MINUS .)
    INTCONST        reduce using rule 103 (unary_op -> MINUS .)
    FLOATCONST      reduce using rule 103 (unary_op -> MINUS .)
    STRINGCONST     reduce using rule 103 (unary_op -> MINUS .)
    NULL            reduce using rule 103 (unary_op -> MINUS .)
    TRUE            reduce using rule 103 (unary_op -> MINUS .)
    FALSE           reduce using rule 103 (unary_op -> MINUS .)
    ID              reduce using rule 103 (unary_op -> MINUS .)


state 116

    (104) unary_op -> NOT .

    THIS            reduce using rule 104 (unary_op -> NOT .)
    SUPER           reduce using rule 104 (unary_op -> NOT .)
    LPAREN          reduce using rule 104 (unary_op -> NOT .)
    NEW             reduce using rule 104 (unary_op -> NOT .)
    PLUSPLUS        reduce using rule 104 (unary_op -> NOT .)
    MINUSMINUS      reduce using rule 104 (unary_op -> NOT .)
    PLUS            reduce using rule 104 (unary_op -> NOT .)
    MINUS           reduce using rule 104 (unary_op -> NOT .)
    NOT             reduce using rule 104 (unary_op -> NOT .)
    INTCONST        reduce using rule 104 (unary_op -> NOT .)
    FLOATCONST      reduce using rule 104 (unary_op -> NOT .)
    STRINGCONST     reduce using rule 104 (unary_op -> NOT .)
    NULL            reduce using rule 104 (unary_op -> NOT .)
    TRUE            reduce using rule 104 (unary_op -> NOT .)
    FALSE           reduce using rule 104 (unary_op -> NOT .)
    ID              reduce using rule 104 (unary_op -> NOT .)


state 117

    (75) lhs -> field_access .
    (76) method_invocation -> field_access . LPAREN RPAREN
    (77) method_invocation -> field_access . LPAREN arguments RPAREN

    EQUALS          reduce using rule 75 (lhs -> field_access .)
    PLUSPLUS        reduce using rule 75 (lhs -> field_access .)
    MINUSMINUS      reduce using rule 75 (lhs -> field_access .)
    PERIOD          reduce using rule 75 (lhs -> field_access .)
    RPAREN          reduce using rule 75 (lhs -> field_access .)
    PLUS            reduce using rule 75 (lhs -> field_access .)
    MINUS           reduce using rule 75 (lhs -> field_access .)
    TIMES           reduce using rule 75 (lhs -> field_access .)
    DIVIDE          reduce using rule 75 (lhs -> field_access .)
    AND             reduce using rule 75 (lhs -> field_access .)
    OR              reduce using rule 75 (lhs -> field_access .)
    EQUALSCOMPARE   reduce using rule 75 (lhs -> field_access .)
    NOTEQUALS       reduce using rule 75 (lhs -> field_access .)
    LESSTHAN        reduce using rule 75 (lhs -> field_access .)
    GREATERTHAN     reduce using rule 75 (lhs -> field_access .)
    LESSTHANOREQ    reduce using rule 75 (lhs -> field_access .)
    GREATERTHANOREQ reduce using rule 75 (lhs -> field_access .)
    SEMICOLON       reduce using rule 75 (lhs -> field_access .)
    COMMA           reduce using rule 75 (lhs -> field_access .)
    LPAREN          shift and go to state 131


state 118

    (48) stmt -> WHILE LPAREN . expr RPAREN stmt
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (75) lhs -> . field_access
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    NOT             shift and go to state 116
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 111

    expr                           shift and go to state 152
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    unary_op                       shift and go to state 110
    literal                        shift and go to state 89
    lhs                            shift and go to state 112
    method_invocation              shift and go to state 113
    field_access                   shift and go to state 117

state 119

    (49) stmt -> FOR LPAREN . stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (75) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE

    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    ID              shift and go to state 111
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    stmt_expr                      shift and go to state 153
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 120

    (52) stmt -> stmt_expr SEMICOLON .

    IF              reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    WHILE           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    FOR             reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    RETURN          reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    BREAK           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    CONTINUE        reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    SEMICOLON       reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    LBRACE          reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    PLUSPLUS        reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    MINUSMINUS      reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    INT             reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    FLOAT           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    BOOLEAN         reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    VOID            reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    ID              reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    THIS            reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    SUPER           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    LPAREN          reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    NEW             reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    INTCONST        reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    FLOATCONST      reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    STRINGCONST     reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    NULL            reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    TRUE            reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    FALSE           reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    RBRACE          reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)
    ELSE            reduce using rule 52 (stmt -> stmt_expr SEMICOLON .)


state 121

    (50) stmt -> RETURN SEMICOLON .

    IF              reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    PLUSPLUS        reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    MINUSMINUS      reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    INT             reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    BOOLEAN         reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    VOID            reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    ID              reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    THIS            reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    SUPER           reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    NEW             reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    INTCONST        reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    FLOATCONST      reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    STRINGCONST     reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    NULL            reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    TRUE            reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    FALSE           reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 50 (stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 50 (stmt -> RETURN SEMICOLON .)


state 122

    (51) stmt -> RETURN expr . SEMICOLON
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQUALSCOMPARE
    (97) bool_op -> . NOTEQUALS
    (98) bool_op -> . LESSTHAN
    (99) bool_op -> . GREATERTHAN
    (100) bool_op -> . LESSTHANOREQ
    (101) bool_op -> . GREATERTHANOREQ

    SEMICOLON       shift and go to state 154
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUALSCOMPARE   shift and go to state 145
    NOTEQUALS       shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LESSTHANOREQ    shift and go to state 149
    GREATERTHANOREQ shift and go to state 150

    arith_op                       shift and go to state 137
    bool_op                        shift and go to state 138

state 123

    (53) stmt -> BREAK SEMICOLON .

    IF              reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    PLUSPLUS        reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    MINUSMINUS      reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    VOID            reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    INTCONST        reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    FLOATCONST      reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    STRINGCONST     reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 53 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 53 (stmt -> BREAK SEMICOLON .)


state 124

    (54) stmt -> CONTINUE SEMICOLON .

    IF              reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    PLUSPLUS        reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    MINUSMINUS      reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    INTCONST        reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    FLOATCONST      reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    STRINGCONST     reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 54 (stmt -> CONTINUE SEMICOLON .)


state 125

    (56) stmt -> var_decl SEMICOLON .

    IF              reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    WHILE           reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    FOR             reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    RETURN          reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    BREAK           reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    CONTINUE        reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    SEMICOLON       reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    LBRACE          reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    PLUSPLUS        reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    MINUSMINUS      reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    INT             reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    FLOAT           reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    BOOLEAN         reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    VOID            reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    ID              reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    THIS            reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    SUPER           reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    LPAREN          reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    NEW             reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    INTCONST        reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    FLOATCONST      reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    STRINGCONST     reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    NULL            reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    TRUE            reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    FALSE           reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    RBRACE          reduce using rule 56 (stmt -> var_decl SEMICOLON .)
    ELSE            reduce using rule 56 (stmt -> var_decl SEMICOLON .)


state 126

    (85) assign -> lhs EQUALS . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (75) lhs -> . field_access
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    NOT             shift and go to state 116
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 111

    lhs                            shift and go to state 112
    expr                           shift and go to state 155
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    unary_op                       shift and go to state 110
    literal                        shift and go to state 89
    method_invocation              shift and go to state 113
    field_access                   shift and go to state 117

state 127

    (86) assign -> lhs PLUSPLUS .

    SEMICOLON       reduce using rule 86 (assign -> lhs PLUSPLUS .)
    RPAREN          reduce using rule 86 (assign -> lhs PLUSPLUS .)
    PLUS            reduce using rule 86 (assign -> lhs PLUSPLUS .)
    MINUS           reduce using rule 86 (assign -> lhs PLUSPLUS .)
    TIMES           reduce using rule 86 (assign -> lhs PLUSPLUS .)
    DIVIDE          reduce using rule 86 (assign -> lhs PLUSPLUS .)
    AND             reduce using rule 86 (assign -> lhs PLUSPLUS .)
    OR              reduce using rule 86 (assign -> lhs PLUSPLUS .)
    EQUALSCOMPARE   reduce using rule 86 (assign -> lhs PLUSPLUS .)
    NOTEQUALS       reduce using rule 86 (assign -> lhs PLUSPLUS .)
    LESSTHAN        reduce using rule 86 (assign -> lhs PLUSPLUS .)
    GREATERTHAN     reduce using rule 86 (assign -> lhs PLUSPLUS .)
    LESSTHANOREQ    reduce using rule 86 (assign -> lhs PLUSPLUS .)
    GREATERTHANOREQ reduce using rule 86 (assign -> lhs PLUSPLUS .)
    COMMA           reduce using rule 86 (assign -> lhs PLUSPLUS .)


state 128

    (88) assign -> lhs MINUSMINUS .

    SEMICOLON       reduce using rule 88 (assign -> lhs MINUSMINUS .)
    RPAREN          reduce using rule 88 (assign -> lhs MINUSMINUS .)
    PLUS            reduce using rule 88 (assign -> lhs MINUSMINUS .)
    MINUS           reduce using rule 88 (assign -> lhs MINUSMINUS .)
    TIMES           reduce using rule 88 (assign -> lhs MINUSMINUS .)
    DIVIDE          reduce using rule 88 (assign -> lhs MINUSMINUS .)
    AND             reduce using rule 88 (assign -> lhs MINUSMINUS .)
    OR              reduce using rule 88 (assign -> lhs MINUSMINUS .)
    EQUALSCOMPARE   reduce using rule 88 (assign -> lhs MINUSMINUS .)
    NOTEQUALS       reduce using rule 88 (assign -> lhs MINUSMINUS .)
    LESSTHAN        reduce using rule 88 (assign -> lhs MINUSMINUS .)
    GREATERTHAN     reduce using rule 88 (assign -> lhs MINUSMINUS .)
    LESSTHANOREQ    reduce using rule 88 (assign -> lhs MINUSMINUS .)
    GREATERTHANOREQ reduce using rule 88 (assign -> lhs MINUSMINUS .)
    COMMA           reduce using rule 88 (assign -> lhs MINUSMINUS .)


state 129

    (87) assign -> PLUSPLUS lhs .
    (70) primary -> lhs .

    SEMICOLON       reduce using rule 87 (assign -> PLUSPLUS lhs .)
    RPAREN          reduce using rule 87 (assign -> PLUSPLUS lhs .)
    PLUS            reduce using rule 87 (assign -> PLUSPLUS lhs .)
    MINUS           reduce using rule 87 (assign -> PLUSPLUS lhs .)
    TIMES           reduce using rule 87 (assign -> PLUSPLUS lhs .)
    DIVIDE          reduce using rule 87 (assign -> PLUSPLUS lhs .)
    AND             reduce using rule 87 (assign -> PLUSPLUS lhs .)
    OR              reduce using rule 87 (assign -> PLUSPLUS lhs .)
    EQUALSCOMPARE   reduce using rule 87 (assign -> PLUSPLUS lhs .)
    NOTEQUALS       reduce using rule 87 (assign -> PLUSPLUS lhs .)
    LESSTHAN        reduce using rule 87 (assign -> PLUSPLUS lhs .)
    GREATERTHAN     reduce using rule 87 (assign -> PLUSPLUS lhs .)
    LESSTHANOREQ    reduce using rule 87 (assign -> PLUSPLUS lhs .)
    GREATERTHANOREQ reduce using rule 87 (assign -> PLUSPLUS lhs .)
    COMMA           reduce using rule 87 (assign -> PLUSPLUS lhs .)
    PERIOD          reduce using rule 70 (primary -> lhs .)


state 130

    (89) assign -> MINUSMINUS lhs .
    (70) primary -> lhs .

    SEMICOLON       reduce using rule 89 (assign -> MINUSMINUS lhs .)
    RPAREN          reduce using rule 89 (assign -> MINUSMINUS lhs .)
    PLUS            reduce using rule 89 (assign -> MINUSMINUS lhs .)
    MINUS           reduce using rule 89 (assign -> MINUSMINUS lhs .)
    TIMES           reduce using rule 89 (assign -> MINUSMINUS lhs .)
    DIVIDE          reduce using rule 89 (assign -> MINUSMINUS lhs .)
    AND             reduce using rule 89 (assign -> MINUSMINUS lhs .)
    OR              reduce using rule 89 (assign -> MINUSMINUS lhs .)
    EQUALSCOMPARE   reduce using rule 89 (assign -> MINUSMINUS lhs .)
    NOTEQUALS       reduce using rule 89 (assign -> MINUSMINUS lhs .)
    LESSTHAN        reduce using rule 89 (assign -> MINUSMINUS lhs .)
    GREATERTHAN     reduce using rule 89 (assign -> MINUSMINUS lhs .)
    LESSTHANOREQ    reduce using rule 89 (assign -> MINUSMINUS lhs .)
    GREATERTHANOREQ reduce using rule 89 (assign -> MINUSMINUS lhs .)
    COMMA           reduce using rule 89 (assign -> MINUSMINUS lhs .)
    PERIOD          reduce using rule 70 (primary -> lhs .)


state 131

    (76) method_invocation -> field_access LPAREN . RPAREN
    (77) method_invocation -> field_access LPAREN . arguments RPAREN
    (72) arguments -> . expr
    (73) arguments -> . arguments COMMA expr
    (74) arguments -> . empty
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (1) empty -> .
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (75) lhs -> . field_access
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 156
    COMMA           reduce using rule 1 (empty -> .)
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    NOT             shift and go to state 116
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 111

  ! RPAREN          [ reduce using rule 1 (empty -> .) ]

    field_access                   shift and go to state 117
    arguments                      shift and go to state 157
    expr                           shift and go to state 158
    empty                          shift and go to state 159
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    unary_op                       shift and go to state 110
    literal                        shift and go to state 89
    lhs                            shift and go to state 112
    method_invocation              shift and go to state 113

state 132

    (78) field_access -> primary PERIOD . ID

    ID              shift and go to state 160


state 133

    (68) primary -> NEW ID . LPAREN arguments RPAREN
    (69) primary -> NEW ID . LPAREN RPAREN

    LPAREN          shift and go to state 161


state 134

    (35) method_decl -> modifier VOID ID LPAREN formals RPAREN block .

    PUBLIC          reduce using rule 35 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 35 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 35 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 35 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    ID              reduce using rule 35 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    INT             reduce using rule 35 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 35 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 35 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    RBRACE          reduce using rule 35 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)


state 135

    (46) stmt -> IF LPAREN expr . RPAREN stmt
    (47) stmt -> IF LPAREN expr . RPAREN stmt ELSE stmt
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQUALSCOMPARE
    (97) bool_op -> . NOTEQUALS
    (98) bool_op -> . LESSTHAN
    (99) bool_op -> . GREATERTHAN
    (100) bool_op -> . LESSTHANOREQ
    (101) bool_op -> . GREATERTHANOREQ

    RPAREN          shift and go to state 162
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUALSCOMPARE   shift and go to state 145
    NOTEQUALS       shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LESSTHANOREQ    shift and go to state 149
    GREATERTHANOREQ shift and go to state 150

    arith_op                       shift and go to state 137
    bool_op                        shift and go to state 138

state 136

    (67) primary -> LPAREN expr RPAREN .

    PERIOD          reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    AND             reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    OR              reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    EQUALSCOMPARE   reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    NOTEQUALS       reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    LESSTHAN        reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    GREATERTHAN     reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    LESSTHANOREQ    reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    GREATERTHANOREQ reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 67 (primary -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 67 (primary -> LPAREN expr RPAREN .)


state 137

    (82) expr -> expr arith_op . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (75) lhs -> . field_access
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    NOT             shift and go to state 116
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 111

    expr                           shift and go to state 163
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    unary_op                       shift and go to state 110
    literal                        shift and go to state 89
    lhs                            shift and go to state 112
    method_invocation              shift and go to state 113
    field_access                   shift and go to state 117

state 138

    (83) expr -> expr bool_op . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (75) lhs -> . field_access
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    NOT             shift and go to state 116
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 111

    expr                           shift and go to state 164
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    unary_op                       shift and go to state 110
    literal                        shift and go to state 89
    lhs                            shift and go to state 112
    method_invocation              shift and go to state 113
    field_access                   shift and go to state 117

state 139

    (90) arith_op -> PLUS .

    THIS            reduce using rule 90 (arith_op -> PLUS .)
    SUPER           reduce using rule 90 (arith_op -> PLUS .)
    LPAREN          reduce using rule 90 (arith_op -> PLUS .)
    NEW             reduce using rule 90 (arith_op -> PLUS .)
    PLUSPLUS        reduce using rule 90 (arith_op -> PLUS .)
    MINUSMINUS      reduce using rule 90 (arith_op -> PLUS .)
    PLUS            reduce using rule 90 (arith_op -> PLUS .)
    MINUS           reduce using rule 90 (arith_op -> PLUS .)
    NOT             reduce using rule 90 (arith_op -> PLUS .)
    INTCONST        reduce using rule 90 (arith_op -> PLUS .)
    FLOATCONST      reduce using rule 90 (arith_op -> PLUS .)
    STRINGCONST     reduce using rule 90 (arith_op -> PLUS .)
    NULL            reduce using rule 90 (arith_op -> PLUS .)
    TRUE            reduce using rule 90 (arith_op -> PLUS .)
    FALSE           reduce using rule 90 (arith_op -> PLUS .)
    ID              reduce using rule 90 (arith_op -> PLUS .)


state 140

    (91) arith_op -> MINUS .

    THIS            reduce using rule 91 (arith_op -> MINUS .)
    SUPER           reduce using rule 91 (arith_op -> MINUS .)
    LPAREN          reduce using rule 91 (arith_op -> MINUS .)
    NEW             reduce using rule 91 (arith_op -> MINUS .)
    PLUSPLUS        reduce using rule 91 (arith_op -> MINUS .)
    MINUSMINUS      reduce using rule 91 (arith_op -> MINUS .)
    PLUS            reduce using rule 91 (arith_op -> MINUS .)
    MINUS           reduce using rule 91 (arith_op -> MINUS .)
    NOT             reduce using rule 91 (arith_op -> MINUS .)
    INTCONST        reduce using rule 91 (arith_op -> MINUS .)
    FLOATCONST      reduce using rule 91 (arith_op -> MINUS .)
    STRINGCONST     reduce using rule 91 (arith_op -> MINUS .)
    NULL            reduce using rule 91 (arith_op -> MINUS .)
    TRUE            reduce using rule 91 (arith_op -> MINUS .)
    FALSE           reduce using rule 91 (arith_op -> MINUS .)
    ID              reduce using rule 91 (arith_op -> MINUS .)


state 141

    (92) arith_op -> TIMES .

    THIS            reduce using rule 92 (arith_op -> TIMES .)
    SUPER           reduce using rule 92 (arith_op -> TIMES .)
    LPAREN          reduce using rule 92 (arith_op -> TIMES .)
    NEW             reduce using rule 92 (arith_op -> TIMES .)
    PLUSPLUS        reduce using rule 92 (arith_op -> TIMES .)
    MINUSMINUS      reduce using rule 92 (arith_op -> TIMES .)
    PLUS            reduce using rule 92 (arith_op -> TIMES .)
    MINUS           reduce using rule 92 (arith_op -> TIMES .)
    NOT             reduce using rule 92 (arith_op -> TIMES .)
    INTCONST        reduce using rule 92 (arith_op -> TIMES .)
    FLOATCONST      reduce using rule 92 (arith_op -> TIMES .)
    STRINGCONST     reduce using rule 92 (arith_op -> TIMES .)
    NULL            reduce using rule 92 (arith_op -> TIMES .)
    TRUE            reduce using rule 92 (arith_op -> TIMES .)
    FALSE           reduce using rule 92 (arith_op -> TIMES .)
    ID              reduce using rule 92 (arith_op -> TIMES .)


state 142

    (93) arith_op -> DIVIDE .

    THIS            reduce using rule 93 (arith_op -> DIVIDE .)
    SUPER           reduce using rule 93 (arith_op -> DIVIDE .)
    LPAREN          reduce using rule 93 (arith_op -> DIVIDE .)
    NEW             reduce using rule 93 (arith_op -> DIVIDE .)
    PLUSPLUS        reduce using rule 93 (arith_op -> DIVIDE .)
    MINUSMINUS      reduce using rule 93 (arith_op -> DIVIDE .)
    PLUS            reduce using rule 93 (arith_op -> DIVIDE .)
    MINUS           reduce using rule 93 (arith_op -> DIVIDE .)
    NOT             reduce using rule 93 (arith_op -> DIVIDE .)
    INTCONST        reduce using rule 93 (arith_op -> DIVIDE .)
    FLOATCONST      reduce using rule 93 (arith_op -> DIVIDE .)
    STRINGCONST     reduce using rule 93 (arith_op -> DIVIDE .)
    NULL            reduce using rule 93 (arith_op -> DIVIDE .)
    TRUE            reduce using rule 93 (arith_op -> DIVIDE .)
    FALSE           reduce using rule 93 (arith_op -> DIVIDE .)
    ID              reduce using rule 93 (arith_op -> DIVIDE .)


state 143

    (94) bool_op -> AND .

    THIS            reduce using rule 94 (bool_op -> AND .)
    SUPER           reduce using rule 94 (bool_op -> AND .)
    LPAREN          reduce using rule 94 (bool_op -> AND .)
    NEW             reduce using rule 94 (bool_op -> AND .)
    PLUSPLUS        reduce using rule 94 (bool_op -> AND .)
    MINUSMINUS      reduce using rule 94 (bool_op -> AND .)
    PLUS            reduce using rule 94 (bool_op -> AND .)
    MINUS           reduce using rule 94 (bool_op -> AND .)
    NOT             reduce using rule 94 (bool_op -> AND .)
    INTCONST        reduce using rule 94 (bool_op -> AND .)
    FLOATCONST      reduce using rule 94 (bool_op -> AND .)
    STRINGCONST     reduce using rule 94 (bool_op -> AND .)
    NULL            reduce using rule 94 (bool_op -> AND .)
    TRUE            reduce using rule 94 (bool_op -> AND .)
    FALSE           reduce using rule 94 (bool_op -> AND .)
    ID              reduce using rule 94 (bool_op -> AND .)


state 144

    (95) bool_op -> OR .

    THIS            reduce using rule 95 (bool_op -> OR .)
    SUPER           reduce using rule 95 (bool_op -> OR .)
    LPAREN          reduce using rule 95 (bool_op -> OR .)
    NEW             reduce using rule 95 (bool_op -> OR .)
    PLUSPLUS        reduce using rule 95 (bool_op -> OR .)
    MINUSMINUS      reduce using rule 95 (bool_op -> OR .)
    PLUS            reduce using rule 95 (bool_op -> OR .)
    MINUS           reduce using rule 95 (bool_op -> OR .)
    NOT             reduce using rule 95 (bool_op -> OR .)
    INTCONST        reduce using rule 95 (bool_op -> OR .)
    FLOATCONST      reduce using rule 95 (bool_op -> OR .)
    STRINGCONST     reduce using rule 95 (bool_op -> OR .)
    NULL            reduce using rule 95 (bool_op -> OR .)
    TRUE            reduce using rule 95 (bool_op -> OR .)
    FALSE           reduce using rule 95 (bool_op -> OR .)
    ID              reduce using rule 95 (bool_op -> OR .)


state 145

    (96) bool_op -> EQUALSCOMPARE .

    THIS            reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    SUPER           reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    LPAREN          reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    NEW             reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    PLUSPLUS        reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    MINUSMINUS      reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    PLUS            reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    MINUS           reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    NOT             reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    INTCONST        reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    FLOATCONST      reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    STRINGCONST     reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    NULL            reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    TRUE            reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    FALSE           reduce using rule 96 (bool_op -> EQUALSCOMPARE .)
    ID              reduce using rule 96 (bool_op -> EQUALSCOMPARE .)


state 146

    (97) bool_op -> NOTEQUALS .

    THIS            reduce using rule 97 (bool_op -> NOTEQUALS .)
    SUPER           reduce using rule 97 (bool_op -> NOTEQUALS .)
    LPAREN          reduce using rule 97 (bool_op -> NOTEQUALS .)
    NEW             reduce using rule 97 (bool_op -> NOTEQUALS .)
    PLUSPLUS        reduce using rule 97 (bool_op -> NOTEQUALS .)
    MINUSMINUS      reduce using rule 97 (bool_op -> NOTEQUALS .)
    PLUS            reduce using rule 97 (bool_op -> NOTEQUALS .)
    MINUS           reduce using rule 97 (bool_op -> NOTEQUALS .)
    NOT             reduce using rule 97 (bool_op -> NOTEQUALS .)
    INTCONST        reduce using rule 97 (bool_op -> NOTEQUALS .)
    FLOATCONST      reduce using rule 97 (bool_op -> NOTEQUALS .)
    STRINGCONST     reduce using rule 97 (bool_op -> NOTEQUALS .)
    NULL            reduce using rule 97 (bool_op -> NOTEQUALS .)
    TRUE            reduce using rule 97 (bool_op -> NOTEQUALS .)
    FALSE           reduce using rule 97 (bool_op -> NOTEQUALS .)
    ID              reduce using rule 97 (bool_op -> NOTEQUALS .)


state 147

    (98) bool_op -> LESSTHAN .

    THIS            reduce using rule 98 (bool_op -> LESSTHAN .)
    SUPER           reduce using rule 98 (bool_op -> LESSTHAN .)
    LPAREN          reduce using rule 98 (bool_op -> LESSTHAN .)
    NEW             reduce using rule 98 (bool_op -> LESSTHAN .)
    PLUSPLUS        reduce using rule 98 (bool_op -> LESSTHAN .)
    MINUSMINUS      reduce using rule 98 (bool_op -> LESSTHAN .)
    PLUS            reduce using rule 98 (bool_op -> LESSTHAN .)
    MINUS           reduce using rule 98 (bool_op -> LESSTHAN .)
    NOT             reduce using rule 98 (bool_op -> LESSTHAN .)
    INTCONST        reduce using rule 98 (bool_op -> LESSTHAN .)
    FLOATCONST      reduce using rule 98 (bool_op -> LESSTHAN .)
    STRINGCONST     reduce using rule 98 (bool_op -> LESSTHAN .)
    NULL            reduce using rule 98 (bool_op -> LESSTHAN .)
    TRUE            reduce using rule 98 (bool_op -> LESSTHAN .)
    FALSE           reduce using rule 98 (bool_op -> LESSTHAN .)
    ID              reduce using rule 98 (bool_op -> LESSTHAN .)


state 148

    (99) bool_op -> GREATERTHAN .

    THIS            reduce using rule 99 (bool_op -> GREATERTHAN .)
    SUPER           reduce using rule 99 (bool_op -> GREATERTHAN .)
    LPAREN          reduce using rule 99 (bool_op -> GREATERTHAN .)
    NEW             reduce using rule 99 (bool_op -> GREATERTHAN .)
    PLUSPLUS        reduce using rule 99 (bool_op -> GREATERTHAN .)
    MINUSMINUS      reduce using rule 99 (bool_op -> GREATERTHAN .)
    PLUS            reduce using rule 99 (bool_op -> GREATERTHAN .)
    MINUS           reduce using rule 99 (bool_op -> GREATERTHAN .)
    NOT             reduce using rule 99 (bool_op -> GREATERTHAN .)
    INTCONST        reduce using rule 99 (bool_op -> GREATERTHAN .)
    FLOATCONST      reduce using rule 99 (bool_op -> GREATERTHAN .)
    STRINGCONST     reduce using rule 99 (bool_op -> GREATERTHAN .)
    NULL            reduce using rule 99 (bool_op -> GREATERTHAN .)
    TRUE            reduce using rule 99 (bool_op -> GREATERTHAN .)
    FALSE           reduce using rule 99 (bool_op -> GREATERTHAN .)
    ID              reduce using rule 99 (bool_op -> GREATERTHAN .)


state 149

    (100) bool_op -> LESSTHANOREQ .

    THIS            reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    SUPER           reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    LPAREN          reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    NEW             reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    PLUSPLUS        reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    MINUSMINUS      reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    PLUS            reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    MINUS           reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    NOT             reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    INTCONST        reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    FLOATCONST      reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    STRINGCONST     reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    NULL            reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    TRUE            reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    FALSE           reduce using rule 100 (bool_op -> LESSTHANOREQ .)
    ID              reduce using rule 100 (bool_op -> LESSTHANOREQ .)


state 150

    (101) bool_op -> GREATERTHANOREQ .

    THIS            reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    SUPER           reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    LPAREN          reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    NEW             reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    PLUSPLUS        reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    MINUSMINUS      reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    PLUS            reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    MINUS           reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    NOT             reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    INTCONST        reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    FLOATCONST      reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    STRINGCONST     reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    NULL            reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    TRUE            reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    FALSE           reduce using rule 101 (bool_op -> GREATERTHANOREQ .)
    ID              reduce using rule 101 (bool_op -> GREATERTHANOREQ .)


state 151

    (84) expr -> unary_op expr .
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQUALSCOMPARE
    (97) bool_op -> . NOTEQUALS
    (98) bool_op -> . LESSTHAN
    (99) bool_op -> . GREATERTHAN
    (100) bool_op -> . LESSTHANOREQ
    (101) bool_op -> . GREATERTHANOREQ

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUALSCOMPARE resolved as shift
  ! shift/reduce conflict for NOTEQUALS resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHANOREQ resolved as shift
  ! shift/reduce conflict for GREATERTHANOREQ resolved as shift
    RPAREN          reduce using rule 84 (expr -> unary_op expr .)
    SEMICOLON       reduce using rule 84 (expr -> unary_op expr .)
    COMMA           reduce using rule 84 (expr -> unary_op expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUALSCOMPARE   shift and go to state 145
    NOTEQUALS       shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LESSTHANOREQ    shift and go to state 149
    GREATERTHANOREQ shift and go to state 150

  ! PLUS            [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! MINUS           [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! TIMES           [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! DIVIDE          [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! AND             [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! OR              [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! EQUALSCOMPARE   [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! NOTEQUALS       [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! LESSTHAN        [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! GREATERTHAN     [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! LESSTHANOREQ    [ reduce using rule 84 (expr -> unary_op expr .) ]
  ! GREATERTHANOREQ [ reduce using rule 84 (expr -> unary_op expr .) ]

    arith_op                       shift and go to state 137
    bool_op                        shift and go to state 138

state 152

    (48) stmt -> WHILE LPAREN expr . RPAREN stmt
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQUALSCOMPARE
    (97) bool_op -> . NOTEQUALS
    (98) bool_op -> . LESSTHAN
    (99) bool_op -> . GREATERTHAN
    (100) bool_op -> . LESSTHANOREQ
    (101) bool_op -> . GREATERTHANOREQ

    RPAREN          shift and go to state 165
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUALSCOMPARE   shift and go to state 145
    NOTEQUALS       shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LESSTHANOREQ    shift and go to state 149
    GREATERTHANOREQ shift and go to state 150

    arith_op                       shift and go to state 137
    bool_op                        shift and go to state 138

state 153

    (49) stmt -> FOR LPAREN stmt_expr . SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt

    SEMICOLON       shift and go to state 166


state 154

    (51) stmt -> RETURN expr SEMICOLON .

    IF              reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    BREAK           reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    CONTINUE        reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    PLUSPLUS        reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    MINUSMINUS      reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    INT             reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    BOOLEAN         reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    VOID            reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    ID              reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    THIS            reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    SUPER           reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    NEW             reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    INTCONST        reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    FLOATCONST      reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    STRINGCONST     reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    NULL            reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    TRUE            reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    FALSE           reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    RBRACE          reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 51 (stmt -> RETURN expr SEMICOLON .)


state 155

    (85) assign -> lhs EQUALS expr .
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQUALSCOMPARE
    (97) bool_op -> . NOTEQUALS
    (98) bool_op -> . LESSTHAN
    (99) bool_op -> . GREATERTHAN
    (100) bool_op -> . LESSTHANOREQ
    (101) bool_op -> . GREATERTHANOREQ

    SEMICOLON       reduce using rule 85 (assign -> lhs EQUALS expr .)
    RPAREN          reduce using rule 85 (assign -> lhs EQUALS expr .)
    COMMA           reduce using rule 85 (assign -> lhs EQUALS expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUALSCOMPARE   shift and go to state 145
    NOTEQUALS       shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LESSTHANOREQ    shift and go to state 149
    GREATERTHANOREQ shift and go to state 150

  ! PLUS            [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! MINUS           [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! TIMES           [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! DIVIDE          [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! AND             [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! OR              [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! EQUALSCOMPARE   [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! NOTEQUALS       [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! LESSTHAN        [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! GREATERTHAN     [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! LESSTHANOREQ    [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]
  ! GREATERTHANOREQ [ reduce using rule 85 (assign -> lhs EQUALS expr .) ]

    arith_op                       shift and go to state 137
    bool_op                        shift and go to state 138

state 156

    (76) method_invocation -> field_access LPAREN RPAREN .

    SEMICOLON       reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    PERIOD          reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    RPAREN          reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    PLUS            reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    MINUS           reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    TIMES           reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    DIVIDE          reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    AND             reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    OR              reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    EQUALSCOMPARE   reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    NOTEQUALS       reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    LESSTHAN        reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    GREATERTHAN     reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    LESSTHANOREQ    reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    GREATERTHANOREQ reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)
    COMMA           reduce using rule 76 (method_invocation -> field_access LPAREN RPAREN .)


state 157

    (77) method_invocation -> field_access LPAREN arguments . RPAREN
    (73) arguments -> arguments . COMMA expr

    RPAREN          shift and go to state 167
    COMMA           shift and go to state 168


state 158

    (72) arguments -> expr .
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQUALSCOMPARE
    (97) bool_op -> . NOTEQUALS
    (98) bool_op -> . LESSTHAN
    (99) bool_op -> . GREATERTHAN
    (100) bool_op -> . LESSTHANOREQ
    (101) bool_op -> . GREATERTHANOREQ

    RPAREN          reduce using rule 72 (arguments -> expr .)
    COMMA           reduce using rule 72 (arguments -> expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUALSCOMPARE   shift and go to state 145
    NOTEQUALS       shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LESSTHANOREQ    shift and go to state 149
    GREATERTHANOREQ shift and go to state 150

    arith_op                       shift and go to state 137
    bool_op                        shift and go to state 138

state 159

    (74) arguments -> empty .

    RPAREN          reduce using rule 74 (arguments -> empty .)
    COMMA           reduce using rule 74 (arguments -> empty .)


state 160

    (78) field_access -> primary PERIOD ID .

    LPAREN          reduce using rule 78 (field_access -> primary PERIOD ID .)
    EQUALS          reduce using rule 78 (field_access -> primary PERIOD ID .)
    PLUSPLUS        reduce using rule 78 (field_access -> primary PERIOD ID .)
    MINUSMINUS      reduce using rule 78 (field_access -> primary PERIOD ID .)
    PERIOD          reduce using rule 78 (field_access -> primary PERIOD ID .)
    RPAREN          reduce using rule 78 (field_access -> primary PERIOD ID .)
    PLUS            reduce using rule 78 (field_access -> primary PERIOD ID .)
    MINUS           reduce using rule 78 (field_access -> primary PERIOD ID .)
    TIMES           reduce using rule 78 (field_access -> primary PERIOD ID .)
    DIVIDE          reduce using rule 78 (field_access -> primary PERIOD ID .)
    AND             reduce using rule 78 (field_access -> primary PERIOD ID .)
    OR              reduce using rule 78 (field_access -> primary PERIOD ID .)
    EQUALSCOMPARE   reduce using rule 78 (field_access -> primary PERIOD ID .)
    NOTEQUALS       reduce using rule 78 (field_access -> primary PERIOD ID .)
    LESSTHAN        reduce using rule 78 (field_access -> primary PERIOD ID .)
    GREATERTHAN     reduce using rule 78 (field_access -> primary PERIOD ID .)
    LESSTHANOREQ    reduce using rule 78 (field_access -> primary PERIOD ID .)
    GREATERTHANOREQ reduce using rule 78 (field_access -> primary PERIOD ID .)
    SEMICOLON       reduce using rule 78 (field_access -> primary PERIOD ID .)
    COMMA           reduce using rule 78 (field_access -> primary PERIOD ID .)


state 161

    (68) primary -> NEW ID LPAREN . arguments RPAREN
    (69) primary -> NEW ID LPAREN . RPAREN
    (72) arguments -> . expr
    (73) arguments -> . arguments COMMA expr
    (74) arguments -> . empty
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (1) empty -> .
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (75) lhs -> . field_access
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 170
    COMMA           reduce using rule 1 (empty -> .)
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    NOT             shift and go to state 116
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 111

  ! RPAREN          [ reduce using rule 1 (empty -> .) ]

    arguments                      shift and go to state 169
    expr                           shift and go to state 158
    empty                          shift and go to state 159
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    unary_op                       shift and go to state 110
    literal                        shift and go to state 89
    lhs                            shift and go to state 112
    method_invocation              shift and go to state 113
    field_access                   shift and go to state 117

state 162

    (46) stmt -> IF LPAREN expr RPAREN . stmt
    (47) stmt -> IF LPAREN expr RPAREN . stmt ELSE stmt
    (46) stmt -> . IF LPAREN expr RPAREN stmt
    (47) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (48) stmt -> . WHILE LPAREN expr RPAREN stmt
    (49) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl SEMICOLON
    (57) stmt -> . SEMICOLON
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (42) block -> . LBRACE block_end RBRACE
    (22) var_decl -> . type variables
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . BOOLEAN
    (26) type -> . VOID
    (27) type -> . ID
    (75) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE

    IF              shift and go to state 69
    WHILE           shift and go to state 71
    FOR             shift and go to state 72
    RETURN          shift and go to state 75
    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 74
    LBRACE          shift and go to state 58
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 51
    ID              shift and go to state 87
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    stmt                           shift and go to state 171
    stmt_expr                      shift and go to state 73
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    type                           shift and go to state 82
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 163

    (82) expr -> expr arith_op expr .
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQUALSCOMPARE
    (97) bool_op -> . NOTEQUALS
    (98) bool_op -> . LESSTHAN
    (99) bool_op -> . GREATERTHAN
    (100) bool_op -> . LESSTHANOREQ
    (101) bool_op -> . GREATERTHANOREQ

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUALSCOMPARE resolved as shift
  ! shift/reduce conflict for NOTEQUALS resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHANOREQ resolved as shift
  ! shift/reduce conflict for GREATERTHANOREQ resolved as shift
    RPAREN          reduce using rule 82 (expr -> expr arith_op expr .)
    SEMICOLON       reduce using rule 82 (expr -> expr arith_op expr .)
    COMMA           reduce using rule 82 (expr -> expr arith_op expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUALSCOMPARE   shift and go to state 145
    NOTEQUALS       shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LESSTHANOREQ    shift and go to state 149
    GREATERTHANOREQ shift and go to state 150

  ! PLUS            [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! MINUS           [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! TIMES           [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! DIVIDE          [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! AND             [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! OR              [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! EQUALSCOMPARE   [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! NOTEQUALS       [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! LESSTHAN        [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! GREATERTHAN     [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! LESSTHANOREQ    [ reduce using rule 82 (expr -> expr arith_op expr .) ]
  ! GREATERTHANOREQ [ reduce using rule 82 (expr -> expr arith_op expr .) ]

    arith_op                       shift and go to state 137
    bool_op                        shift and go to state 138

state 164

    (83) expr -> expr bool_op expr .
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQUALSCOMPARE
    (97) bool_op -> . NOTEQUALS
    (98) bool_op -> . LESSTHAN
    (99) bool_op -> . GREATERTHAN
    (100) bool_op -> . LESSTHANOREQ
    (101) bool_op -> . GREATERTHANOREQ

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUALSCOMPARE resolved as shift
  ! shift/reduce conflict for NOTEQUALS resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for LESSTHANOREQ resolved as shift
  ! shift/reduce conflict for GREATERTHANOREQ resolved as shift
    RPAREN          reduce using rule 83 (expr -> expr bool_op expr .)
    SEMICOLON       reduce using rule 83 (expr -> expr bool_op expr .)
    COMMA           reduce using rule 83 (expr -> expr bool_op expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUALSCOMPARE   shift and go to state 145
    NOTEQUALS       shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LESSTHANOREQ    shift and go to state 149
    GREATERTHANOREQ shift and go to state 150

  ! PLUS            [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! MINUS           [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! TIMES           [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! DIVIDE          [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! AND             [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! OR              [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! EQUALSCOMPARE   [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! NOTEQUALS       [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! LESSTHAN        [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! GREATERTHAN     [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! LESSTHANOREQ    [ reduce using rule 83 (expr -> expr bool_op expr .) ]
  ! GREATERTHANOREQ [ reduce using rule 83 (expr -> expr bool_op expr .) ]

    bool_op                        shift and go to state 138
    arith_op                       shift and go to state 137

state 165

    (48) stmt -> WHILE LPAREN expr RPAREN . stmt
    (46) stmt -> . IF LPAREN expr RPAREN stmt
    (47) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (48) stmt -> . WHILE LPAREN expr RPAREN stmt
    (49) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl SEMICOLON
    (57) stmt -> . SEMICOLON
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (42) block -> . LBRACE block_end RBRACE
    (22) var_decl -> . type variables
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . BOOLEAN
    (26) type -> . VOID
    (27) type -> . ID
    (75) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE

    IF              shift and go to state 69
    WHILE           shift and go to state 71
    FOR             shift and go to state 72
    RETURN          shift and go to state 75
    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 74
    LBRACE          shift and go to state 58
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 51
    ID              shift and go to state 87
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    stmt                           shift and go to state 172
    stmt_expr                      shift and go to state 73
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    type                           shift and go to state 82
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 166

    (49) stmt -> FOR LPAREN stmt_expr SEMICOLON . expr SEMICOLON stmt_expr RPAREN stmt
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (75) lhs -> . field_access
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    NOT             shift and go to state 116
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 111

    expr                           shift and go to state 173
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    unary_op                       shift and go to state 110
    literal                        shift and go to state 89
    lhs                            shift and go to state 112
    method_invocation              shift and go to state 113
    field_access                   shift and go to state 117

state 167

    (77) method_invocation -> field_access LPAREN arguments RPAREN .

    SEMICOLON       reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    PERIOD          reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    PLUS            reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    MINUS           reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    TIMES           reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    AND             reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    OR              reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    EQUALSCOMPARE   reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    NOTEQUALS       reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESSTHAN        reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATERTHAN     reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESSTHANOREQ    reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATERTHANOREQ reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)
    COMMA           reduce using rule 77 (method_invocation -> field_access LPAREN arguments RPAREN .)


state 168

    (73) arguments -> arguments COMMA . expr
    (80) expr -> . primary
    (81) expr -> . assign
    (82) expr -> . expr arith_op expr
    (83) expr -> . expr bool_op expr
    (84) expr -> . unary_op expr
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (102) unary_op -> . PLUS
    (103) unary_op -> . MINUS
    (104) unary_op -> . NOT
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE
    (75) lhs -> . field_access
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID

    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    PLUS            shift and go to state 114
    MINUS           shift and go to state 115
    NOT             shift and go to state 116
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98
    ID              shift and go to state 111

    expr                           shift and go to state 174
    primary                        shift and go to state 108
    assign                         shift and go to state 109
    unary_op                       shift and go to state 110
    literal                        shift and go to state 89
    lhs                            shift and go to state 112
    method_invocation              shift and go to state 113
    field_access                   shift and go to state 117

state 169

    (68) primary -> NEW ID LPAREN arguments . RPAREN
    (73) arguments -> arguments . COMMA expr

    RPAREN          shift and go to state 175
    COMMA           shift and go to state 168


state 170

    (69) primary -> NEW ID LPAREN RPAREN .

    PERIOD          reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    RPAREN          reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    PLUS            reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    MINUS           reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    TIMES           reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    AND             reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    OR              reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    EQUALSCOMPARE   reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    NOTEQUALS       reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    LESSTHAN        reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    GREATERTHAN     reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    LESSTHANOREQ    reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    GREATERTHANOREQ reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)
    COMMA           reduce using rule 69 (primary -> NEW ID LPAREN RPAREN .)


state 171

    (46) stmt -> IF LPAREN expr RPAREN stmt .
    (47) stmt -> IF LPAREN expr RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    IF              reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    PLUSPLUS        reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    MINUSMINUS      reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    INT             reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    VOID            reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    ID              reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    INTCONST        reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    FLOATCONST      reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    STRINGCONST     reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .)
    ELSE            shift and go to state 176

  ! ELSE            [ reduce using rule 46 (stmt -> IF LPAREN expr RPAREN stmt .) ]


state 172

    (48) stmt -> WHILE LPAREN expr RPAREN stmt .

    IF              reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    PLUSPLUS        reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    MINUSMINUS      reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INT             reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    VOID            reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ID              reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    INTCONST        reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FLOATCONST      reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    STRINGCONST     reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    RBRACE          reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 48 (stmt -> WHILE LPAREN expr RPAREN stmt .)


state 173

    (49) stmt -> FOR LPAREN stmt_expr SEMICOLON expr . SEMICOLON stmt_expr RPAREN stmt
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQUALSCOMPARE
    (97) bool_op -> . NOTEQUALS
    (98) bool_op -> . LESSTHAN
    (99) bool_op -> . GREATERTHAN
    (100) bool_op -> . LESSTHANOREQ
    (101) bool_op -> . GREATERTHANOREQ

    SEMICOLON       shift and go to state 177
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUALSCOMPARE   shift and go to state 145
    NOTEQUALS       shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LESSTHANOREQ    shift and go to state 149
    GREATERTHANOREQ shift and go to state 150

    arith_op                       shift and go to state 137
    bool_op                        shift and go to state 138

state 174

    (73) arguments -> arguments COMMA expr .
    (82) expr -> expr . arith_op expr
    (83) expr -> expr . bool_op expr
    (90) arith_op -> . PLUS
    (91) arith_op -> . MINUS
    (92) arith_op -> . TIMES
    (93) arith_op -> . DIVIDE
    (94) bool_op -> . AND
    (95) bool_op -> . OR
    (96) bool_op -> . EQUALSCOMPARE
    (97) bool_op -> . NOTEQUALS
    (98) bool_op -> . LESSTHAN
    (99) bool_op -> . GREATERTHAN
    (100) bool_op -> . LESSTHANOREQ
    (101) bool_op -> . GREATERTHANOREQ

    RPAREN          reduce using rule 73 (arguments -> arguments COMMA expr .)
    COMMA           reduce using rule 73 (arguments -> arguments COMMA expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    TIMES           shift and go to state 141
    DIVIDE          shift and go to state 142
    AND             shift and go to state 143
    OR              shift and go to state 144
    EQUALSCOMPARE   shift and go to state 145
    NOTEQUALS       shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LESSTHANOREQ    shift and go to state 149
    GREATERTHANOREQ shift and go to state 150

    arith_op                       shift and go to state 137
    bool_op                        shift and go to state 138

state 175

    (68) primary -> NEW ID LPAREN arguments RPAREN .

    PERIOD          reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    PLUS            reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    MINUS           reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    TIMES           reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    AND             reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    OR              reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    EQUALSCOMPARE   reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    NOTEQUALS       reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    LESSTHAN        reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    GREATERTHAN     reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    LESSTHANOREQ    reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    GREATERTHANOREQ reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)
    COMMA           reduce using rule 68 (primary -> NEW ID LPAREN arguments RPAREN .)


state 176

    (47) stmt -> IF LPAREN expr RPAREN stmt ELSE . stmt
    (46) stmt -> . IF LPAREN expr RPAREN stmt
    (47) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (48) stmt -> . WHILE LPAREN expr RPAREN stmt
    (49) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl SEMICOLON
    (57) stmt -> . SEMICOLON
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (42) block -> . LBRACE block_end RBRACE
    (22) var_decl -> . type variables
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . BOOLEAN
    (26) type -> . VOID
    (27) type -> . ID
    (75) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE

    IF              shift and go to state 69
    WHILE           shift and go to state 71
    FOR             shift and go to state 72
    RETURN          shift and go to state 75
    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 74
    LBRACE          shift and go to state 58
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 51
    ID              shift and go to state 87
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    stmt                           shift and go to state 178
    stmt_expr                      shift and go to state 73
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    type                           shift and go to state 82
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 177

    (49) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON . stmt_expr RPAREN stmt
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (75) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE

    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    ID              shift and go to state 111
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    stmt_expr                      shift and go to state 179
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 178

    (47) stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .

    IF              reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BREAK           reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    CONTINUE        reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    SEMICOLON       reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LBRACE          reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    PLUSPLUS        reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    MINUSMINUS      reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INT             reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FLOAT           reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    BOOLEAN         reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    VOID            reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ID              reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    THIS            reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    SUPER           reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LPAREN          reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NEW             reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    INTCONST        reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FLOATCONST      reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    STRINGCONST     reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    NULL            reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    TRUE            reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FALSE           reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RBRACE          reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 47 (stmt -> IF LPAREN expr RPAREN stmt ELSE stmt .)


state 179

    (49) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr . RPAREN stmt

    RPAREN          shift and go to state 180


state 180

    (49) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN . stmt
    (46) stmt -> . IF LPAREN expr RPAREN stmt
    (47) stmt -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (48) stmt -> . WHILE LPAREN expr RPAREN stmt
    (49) stmt -> . FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt
    (50) stmt -> . RETURN SEMICOLON
    (51) stmt -> . RETURN expr SEMICOLON
    (52) stmt -> . stmt_expr SEMICOLON
    (53) stmt -> . BREAK SEMICOLON
    (54) stmt -> . CONTINUE SEMICOLON
    (55) stmt -> . block
    (56) stmt -> . var_decl SEMICOLON
    (57) stmt -> . SEMICOLON
    (105) stmt_expr -> . assign
    (106) stmt_expr -> . method_invocation
    (42) block -> . LBRACE block_end RBRACE
    (22) var_decl -> . type variables
    (85) assign -> . lhs EQUALS expr
    (86) assign -> . lhs PLUSPLUS
    (87) assign -> . PLUSPLUS lhs
    (88) assign -> . lhs MINUSMINUS
    (89) assign -> . MINUSMINUS lhs
    (76) method_invocation -> . field_access LPAREN RPAREN
    (77) method_invocation -> . field_access LPAREN arguments RPAREN
    (23) type -> . INT
    (24) type -> . FLOAT
    (25) type -> . BOOLEAN
    (26) type -> . VOID
    (27) type -> . ID
    (75) lhs -> . field_access
    (78) field_access -> . primary PERIOD ID
    (79) field_access -> . ID
    (64) primary -> . literal
    (65) primary -> . THIS
    (66) primary -> . SUPER
    (67) primary -> . LPAREN expr RPAREN
    (68) primary -> . NEW ID LPAREN arguments RPAREN
    (69) primary -> . NEW ID LPAREN RPAREN
    (70) primary -> . lhs
    (71) primary -> . method_invocation
    (58) literal -> . INTCONST
    (59) literal -> . FLOATCONST
    (60) literal -> . STRINGCONST
    (61) literal -> . NULL
    (62) literal -> . TRUE
    (63) literal -> . FALSE

    IF              shift and go to state 69
    WHILE           shift and go to state 71
    FOR             shift and go to state 72
    RETURN          shift and go to state 75
    BREAK           shift and go to state 76
    CONTINUE        shift and go to state 77
    SEMICOLON       shift and go to state 74
    LBRACE          shift and go to state 58
    PLUSPLUS        shift and go to state 84
    MINUSMINUS      shift and go to state 85
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    BOOLEAN         shift and go to state 32
    VOID            shift and go to state 51
    ID              shift and go to state 87
    THIS            shift and go to state 90
    SUPER           shift and go to state 91
    LPAREN          shift and go to state 70
    NEW             shift and go to state 92
    INTCONST        shift and go to state 93
    FLOATCONST      shift and go to state 94
    STRINGCONST     shift and go to state 95
    NULL            shift and go to state 96
    TRUE            shift and go to state 97
    FALSE           shift and go to state 98

    stmt_expr                      shift and go to state 73
    stmt                           shift and go to state 181
    block                          shift and go to state 78
    var_decl                       shift and go to state 79
    assign                         shift and go to state 80
    method_invocation              shift and go to state 81
    type                           shift and go to state 82
    lhs                            shift and go to state 83
    field_access                   shift and go to state 86
    primary                        shift and go to state 88
    literal                        shift and go to state 89

state 181

    (49) stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .

    IF              reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    WHILE           reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FOR             reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    RETURN          reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    BREAK           reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    CONTINUE        reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    SEMICOLON       reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    LBRACE          reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    PLUSPLUS        reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    MINUSMINUS      reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    INT             reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FLOAT           reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    BOOLEAN         reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    VOID            reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    ID              reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    THIS            reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    SUPER           reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    LPAREN          reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    NEW             reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    INTCONST        reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FLOATCONST      reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    STRINGCONST     reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    NULL            reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    TRUE            reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    FALSE           reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    RBRACE          reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)
    ELSE            reduce using rule 49 (stmt -> FOR LPAREN stmt_expr SEMICOLON expr SEMICOLON stmt_expr RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 29 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 40 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 43 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 52 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 131 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 151 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 151 resolved as shift
WARNING: shift/reduce conflict for AND in state 151 resolved as shift
WARNING: shift/reduce conflict for OR in state 151 resolved as shift
WARNING: shift/reduce conflict for EQUALSCOMPARE in state 151 resolved as shift
WARNING: shift/reduce conflict for NOTEQUALS in state 151 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 151 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 151 resolved as shift
WARNING: shift/reduce conflict for LESSTHANOREQ in state 151 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANOREQ in state 151 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 161 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 163 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 163 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 163 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 163 resolved as shift
WARNING: shift/reduce conflict for AND in state 163 resolved as shift
WARNING: shift/reduce conflict for OR in state 163 resolved as shift
WARNING: shift/reduce conflict for EQUALSCOMPARE in state 163 resolved as shift
WARNING: shift/reduce conflict for NOTEQUALS in state 163 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 163 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 163 resolved as shift
WARNING: shift/reduce conflict for LESSTHANOREQ in state 163 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANOREQ in state 163 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 164 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 164 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 164 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 164 resolved as shift
WARNING: shift/reduce conflict for AND in state 164 resolved as shift
WARNING: shift/reduce conflict for OR in state 164 resolved as shift
WARNING: shift/reduce conflict for EQUALSCOMPARE in state 164 resolved as shift
WARNING: shift/reduce conflict for NOTEQUALS in state 164 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 164 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 164 resolved as shift
WARNING: shift/reduce conflict for LESSTHANOREQ in state 164 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANOREQ in state 164 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 171 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (empty -> <empty>)
WARNING: rejected rule (class_body_sub_decls -> method_decl) in state 12
WARNING: reduce/reduce conflict in state 13 resolved using rule (empty -> <empty>)
WARNING: rejected rule (class_body_sub_decls -> constructor_decl) in state 13
WARNING: reduce/reduce conflict in state 23 resolved using rule (empty -> <empty>)
WARNING: rejected rule (class_body_sub_decls -> field_decl SEMICOLON) in state 23
WARNING: reduce/reduce conflict in state 67 resolved using rule (empty -> <empty>)
WARNING: rejected rule (block_end -> stmt) in state 67
WARNING: Rule (class_body_sub_decls -> method_decl) is never reduced
WARNING: Rule (class_body_sub_decls -> constructor_decl) is never reduced
WARNING: Rule (class_body_sub_decls -> field_decl SEMICOLON) is never reduced
WARNING: Rule (block_end -> stmt) is never reduced
